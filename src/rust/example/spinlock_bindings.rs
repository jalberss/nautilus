/* automatically generated by rust-bindgen */

pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const RFLAGS_CF: u32 = 1;
pub const RFLAGS_PF: u32 = 4;
pub const RFLAGS_AF: u32 = 16;
pub const RFLAGS_ZF: u32 = 64;
pub const RFLAGS_SF: u32 = 128;
pub const RFLAGS_TF: u32 = 256;
pub const RFLAGS_IF: u32 = 512;
pub const RFLAGS_DF: u32 = 1024;
pub const RFLAGS_OF: u32 = 2048;
pub const RFLAGS_IOPL: u32 = 12288;
pub const RFLAGS_VM: u32 = 143360;
pub const RFLAGS_VIF: u32 = 524288;
pub const RFLAGS_VIP: u32 = 1048576;
pub const CR0_PE: u32 = 1;
pub const CR0_MP: u32 = 2;
pub const CR0_EM: u32 = 4;
pub const CR0_TS: u32 = 8;
pub const CR0_NE: u32 = 32;
pub const CR0_WP: u32 = 65536;
pub const CR0_AM: u32 = 262144;
pub const CR0_NW: u32 = 536870912;
pub const CR0_CD: u32 = 1073741824;
pub const CR0_PG: u32 = 2147483648;
pub const CR4_VME: u32 = 1;
pub const CR4_PVI: u32 = 2;
pub const CR4_TSD: u32 = 4;
pub const CR4_DE: u32 = 8;
pub const CR4_PSE: u32 = 16;
pub const CR4_PAE: u32 = 32;
pub const CR4_MCE: u32 = 64;
pub const CR4_PGE: u32 = 128;
pub const CR4_PCE: u32 = 256;
pub const CR4_OSFXSR: u32 = 512;
pub const CR4_OSXMMEXCPT: u32 = 1024;
pub const CR4_VMXE: u32 = 8192;
pub const CR4_XMXE: u32 = 16384;
pub const CR4_FSGSBASE: u32 = 65536;
pub const CR4_PCIDE: u32 = 131072;
pub const CR4_OSXSAVE: u32 = 262144;
pub const CR4_SMEP: u32 = 1048576;
pub const IA32_TIME_STAMP_COUNTER: u32 = 16;
pub const IA32_MSR_EFER: u32 = 3221225600;
pub const IA32_MSR_APIC_BASE: u32 = 27;
pub const IA32_MISC_ENABLES: u32 = 416;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NXE: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const EFER_TCE: u32 = 32768;
pub const AMD_MSR_TSC: u32 = 16;
pub const AMD_MSR_APIC_BASE: u32 = 27;
pub const AMD_MSR_MPERF: u32 = 231;
pub const AMD_MSR_APERF: u32 = 232;
pub const AMD_MSR_MTRRCAP: u32 = 254;
pub const AMD_MSR_SYSENTER_CS: u32 = 372;
pub const AMD_MSR_SYSENTER_ESP: u32 = 373;
pub const AMD_MSR_SYSENTER_EIP: u32 = 374;
pub const AMD_MSR_MCG_CAP: u32 = 377;
pub const AMD_MSR_MCG_STATUS: u32 = 378;
pub const AMD_MSR_MCG_CTL: u32 = 379;
pub const AMD_MSR_DEBUG_CTL: u32 = 473;
pub const AMD_MSR_PAT: u32 = 631;
pub const AMD_MSR_STAR: u32 = 3221225601;
pub const AMD_MSR_LSTAR: u32 = 3221225602;
pub const AMD_MSR_CSTAR: u32 = 3221225603;
pub const AMD_MSR_SFMASK: u32 = 3221225604;
pub const AMD_MSR_FSBASE: u32 = 3221225728;
pub const AMD_MSR_GSBASE: u32 = 3221225729;
pub const AMD_MSR_KERN_GSBASE: u32 = 3221225730;
pub const AMD_MSR_TSC_AUX: u32 = 3221225731;
pub const AMD_MSR_SYSCFG: u32 = 3221291024;
pub const AMD_MSR_VM_CR: u32 = 3221291284;
pub const AMD_MSR_NBRIDGE_CTL: u32 = 3221291039;
pub const INSTR_CAL_LOOPS: u32 = 1000;
pub const SPINLOCK_INITIALIZER: u32 = 0;
pub type schar_t = ::std::os::raw::c_schar;
pub type uchar_t = ::std::os::raw::c_uchar;
pub type sshort_t = ::std::os::raw::c_short;
pub type ushort_t = ::std::os::raw::c_ushort;
pub type sint_t = ::std::os::raw::c_int;
pub type uint_t = ::std::os::raw::c_uint;
pub type sllong_t = ::std::os::raw::c_longlong;
pub type ullong_t = ::std::os::raw::c_ulonglong;
pub type slong_t = ::std::os::raw::c_long;
pub type ulong_t = ::std::os::raw::c_ulong;
pub type off_t = ::std::os::raw::c_ulong;
pub type sint64_t = ::std::os::raw::c_long;
pub type sint32_t = ::std::os::raw::c_int;
pub type sint16_t = ::std::os::raw::c_short;
pub type sint8_t = ::std::os::raw::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
extern "C" {
    pub fn nk_detect_cpu_freq(arg1: u32) -> ulong_t;
}
extern "C" {
    pub fn nk_is_amd() -> u8;
}
extern "C" {
    pub fn nk_is_intel() -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_regs {
    pub r15: ulong_t,
    pub r14: ulong_t,
    pub r13: ulong_t,
    pub r12: ulong_t,
    pub r11: ulong_t,
    pub r10: ulong_t,
    pub r9: ulong_t,
    pub r8: ulong_t,
    pub rbp: ulong_t,
    pub rdi: ulong_t,
    pub rsi: ulong_t,
    pub rdx: ulong_t,
    pub rcx: ulong_t,
    pub rbx: ulong_t,
    pub rax: ulong_t,
    pub vector: ulong_t,
    pub err_code: ulong_t,
    pub rip: ulong_t,
    pub cs: ulong_t,
    pub rflags: ulong_t,
    pub rsp: ulong_t,
    pub ss: ulong_t,
}
#[test]
fn bindgen_test_layout_nk_regs() {
    assert_eq!(
        ::std::mem::size_of::<nk_regs>(),
        176usize,
        concat!("Size of: ", stringify!(nk_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<nk_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r11 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r10 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r9 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).r8 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rbp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rdi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rsi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rdx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rcx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rbx as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rax as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).vector as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).err_code as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rip as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rflags as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).rsp as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_regs>())).ss as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(ss)
        )
    );
}
extern "C" {
    pub fn msr_write(msr: u32, data: u64);
}
extern "C" {
    pub fn msr_read(msr: u32) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_hashtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_malloc_data() {
    assert_eq!(
        ::std::mem::size_of::<malloc_data>(),
        40usize,
        concat!("Size of: ", stringify!(malloc_data))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_data>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_free_data() {
    assert_eq!(
        ::std::mem::size_of::<free_data>(),
        40usize,
        concat!("Size of: ", stringify!(free_data))
    );
    assert_eq!(
        ::std::mem::align_of::<free_data>(),
        8usize,
        concat!("Alignment of ", stringify!(free_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_irq_data() {
    assert_eq!(
        ::std::mem::size_of::<irq_data>(),
        40usize,
        concat!("Size of: ", stringify!(irq_data))
    );
    assert_eq!(
        ::std::mem::align_of::<irq_data>(),
        8usize,
        concat!("Alignment of ", stringify!(irq_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_switch_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_thread_switch_data() {
    assert_eq!(
        ::std::mem::size_of::<thread_switch_data>(),
        40usize,
        concat!("Size of: ", stringify!(thread_switch_data))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_switch_data>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_switch_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_switch_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_switch_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_switch_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_switch_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_switch_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_instr_data {
    pub func_htable: *mut nk_hashtable,
    pub irqstat: irq_data,
    pub mallocstat: malloc_data,
    pub freestat: free_data,
    pub thr_switch: thread_switch_data,
}
#[test]
fn bindgen_test_layout_nk_instr_data() {
    assert_eq!(
        ::std::mem::size_of::<nk_instr_data>(),
        168usize,
        concat!("Size of: ", stringify!(nk_instr_data))
    );
    assert_eq!(
        ::std::mem::align_of::<nk_instr_data>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_instr_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_instr_data>())).func_htable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(func_htable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_instr_data>())).irqstat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(irqstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_instr_data>())).mallocstat as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(mallocstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_instr_data>())).freestat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(freestat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nk_instr_data>())).thr_switch as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(thr_switch)
        )
    );
}
extern "C" {
    pub fn nk_profile_func_enter(func: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_profile_func_exit(func: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_thr_switch_prof_enter();
}
extern "C" {
    pub fn nk_thr_switch_prof_exit();
}
extern "C" {
    pub fn nk_irq_prof_enter();
}
extern "C" {
    pub fn nk_irq_prof_exit();
}
extern "C" {
    pub fn nk_malloc_enter();
}
extern "C" {
    pub fn nk_malloc_exit();
}
extern "C" {
    pub fn nk_free_enter();
}
extern "C" {
    pub fn nk_free_exit();
}
extern "C" {
    pub fn nk_instrument_init();
}
extern "C" {
    pub fn nk_instrument_start();
}
extern "C" {
    pub fn nk_instrument_end();
}
extern "C" {
    pub fn nk_instrument_query();
}
extern "C" {
    pub fn nk_instrument_clear();
}
extern "C" {
    pub fn nk_instrument_calibrate(loops: ::std::os::raw::c_uint);
}
pub type spinlock_t = u32;
extern "C" {
    pub fn spinlock_init(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spinlock_deinit(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_nopause(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_irq_save_nopause(lock: *mut spinlock_t) -> u8;
}
// Loses volatile, inline and this binding was not generated
extern "C" {
    pub fn spin_lock_irq_save(lock: *mut spinlock_t) -> u8;
}
