/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__: &'static [u8; 28usize] = b"8.0.1 (branches/release_80)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Clang 8.0.1 (branches/release_80)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const NAUT_CONFIG_X86_64_HOST: u32 = 1;
pub const NAUT_CONFIG_MAX_CPUS: u32 = 256;
pub const NAUT_CONFIG_MAX_IOAPICS: u32 = 16;
pub const NAUT_CONFIG_USE_NAUT_BUILTINS: u32 = 1;
pub const NAUT_CONFIG_CXX_SUPPORT: u32 = 1;
pub const NAUT_CONFIG_RUST_SUPPORT: u32 = 1;
pub const NAUT_CONFIG_TOOLCHAIN_ROOT: &'static [u8; 1usize] = b"\0";
pub const NAUT_CONFIG_MAX_THREADS: u32 = 1024;
pub const NAUT_CONFIG_THREAD_EXIT_KEYCODE: u32 = 196;
pub const NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR: u32 = 1;
pub const NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL: u32 = 1;
pub const NAUT_CONFIG_UTILIZATION_LIMIT: u32 = 99;
pub const NAUT_CONFIG_SPORADIC_RESERVATION: u32 = 10;
pub const NAUT_CONFIG_APERIODIC_RESERVATION: u32 = 10;
pub const NAUT_CONFIG_HZ: u32 = 10;
pub const NAUT_CONFIG_INTERRUPT_REINJECTION_DELAY_NS: u32 = 10000;
pub const NAUT_CONFIG_APERIODIC_ROUND_ROBIN: u32 = 1;
pub const NAUT_CONFIG_FPU_SAVE: u32 = 1;
pub const NAUT_CONFIG_KICK_SCHEDULE: u32 = 1;
pub const NAUT_CONFIG_HALT_WHILE_IDLE: u32 = 1;
pub const NAUT_CONFIG_DEBUG_INFO: u32 = 1;
pub const NAUT_CONFIG_DEBUG_PRINTS: u32 = 1;
pub const NAUT_CONFIG_ENABLE_ASSERTS: u32 = 1;
pub const NAUT_CONFIG_RACKET_RT: u32 = 1;
pub const NAUT_CONFIG_SERIAL_REDIRECT: u32 = 1;
pub const NAUT_CONFIG_SERIAL_REDIRECT_PORT: u32 = 1;
pub const NAUT_CONFIG_DISABLE_PS2_MOUSE: u32 = 1;
pub const NAUT_CONFIG_ATA: u32 = 1;
pub const NAUT_CONFIG_DEBUG_ATA: u32 = 1;
pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const RFLAGS_CF: u32 = 1;
pub const RFLAGS_PF: u32 = 4;
pub const RFLAGS_AF: u32 = 16;
pub const RFLAGS_ZF: u32 = 64;
pub const RFLAGS_SF: u32 = 128;
pub const RFLAGS_TF: u32 = 256;
pub const RFLAGS_IF: u32 = 512;
pub const RFLAGS_DF: u32 = 1024;
pub const RFLAGS_OF: u32 = 2048;
pub const RFLAGS_IOPL: u32 = 12288;
pub const RFLAGS_VM: u32 = 143360;
pub const RFLAGS_VIF: u32 = 524288;
pub const RFLAGS_VIP: u32 = 1048576;
pub const CR0_PE: u32 = 1;
pub const CR0_MP: u32 = 2;
pub const CR0_EM: u32 = 4;
pub const CR0_TS: u32 = 8;
pub const CR0_NE: u32 = 32;
pub const CR0_WP: u32 = 65536;
pub const CR0_AM: u32 = 262144;
pub const CR0_NW: u32 = 536870912;
pub const CR0_CD: u32 = 1073741824;
pub const CR0_PG: u32 = 2147483648;
pub const CR4_VME: u32 = 1;
pub const CR4_PVI: u32 = 2;
pub const CR4_TSD: u32 = 4;
pub const CR4_DE: u32 = 8;
pub const CR4_PSE: u32 = 16;
pub const CR4_PAE: u32 = 32;
pub const CR4_MCE: u32 = 64;
pub const CR4_PGE: u32 = 128;
pub const CR4_PCE: u32 = 256;
pub const CR4_OSFXSR: u32 = 512;
pub const CR4_OSXMMEXCPT: u32 = 1024;
pub const CR4_VMXE: u32 = 8192;
pub const CR4_XMXE: u32 = 16384;
pub const CR4_FSGSBASE: u32 = 65536;
pub const CR4_PCIDE: u32 = 131072;
pub const CR4_OSXSAVE: u32 = 262144;
pub const CR4_SMEP: u32 = 1048576;
pub const IA32_TIME_STAMP_COUNTER: u32 = 16;
pub const IA32_MSR_EFER: u32 = 3221225600;
pub const IA32_MSR_APIC_BASE: u32 = 27;
pub const IA32_MISC_ENABLES: u32 = 416;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NXE: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const EFER_TCE: u32 = 32768;
pub const AMD_MSR_TSC: u32 = 16;
pub const AMD_MSR_APIC_BASE: u32 = 27;
pub const AMD_MSR_MPERF: u32 = 231;
pub const AMD_MSR_APERF: u32 = 232;
pub const AMD_MSR_MTRRCAP: u32 = 254;
pub const AMD_MSR_SYSENTER_CS: u32 = 372;
pub const AMD_MSR_SYSENTER_ESP: u32 = 373;
pub const AMD_MSR_SYSENTER_EIP: u32 = 374;
pub const AMD_MSR_MCG_CAP: u32 = 377;
pub const AMD_MSR_MCG_STATUS: u32 = 378;
pub const AMD_MSR_MCG_CTL: u32 = 379;
pub const AMD_MSR_DEBUG_CTL: u32 = 473;
pub const AMD_MSR_PAT: u32 = 631;
pub const AMD_MSR_STAR: u32 = 3221225601;
pub const AMD_MSR_LSTAR: u32 = 3221225602;
pub const AMD_MSR_CSTAR: u32 = 3221225603;
pub const AMD_MSR_SFMASK: u32 = 3221225604;
pub const AMD_MSR_FSBASE: u32 = 3221225728;
pub const AMD_MSR_GSBASE: u32 = 3221225729;
pub const AMD_MSR_KERN_GSBASE: u32 = 3221225730;
pub const AMD_MSR_TSC_AUX: u32 = 3221225731;
pub const AMD_MSR_SYSCFG: u32 = 3221291024;
pub const AMD_MSR_VM_CR: u32 = 3221291284;
pub const AMD_MSR_NBRIDGE_CTL: u32 = 3221291039;
pub const INSTR_CAL_LOOPS: u32 = 1000;
pub const SPINLOCK_INITIALIZER: u32 = 0;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _D: u32 = 4;
pub const _C: u32 = 8;
pub const _P: u32 = 16;
pub const _S: u32 = 32;
pub const _X: u32 = 64;
pub const _SP: u32 = 128;
pub const OP_T_THRES: u32 = 8;
pub const CPU_ANY: i32 = -1;
pub const TSTACK_DEFAULT: u32 = 0;
pub const TSTACK_4KB: u32 = 4096;
pub const TSTACK_1MB: u32 = 1048576;
pub const TSTACK_2MB: u32 = 2097152;
pub const XSAVE_SIZE: u32 = 4096;
pub const XSAVE_ALIGN: u32 = 64;
pub const FXSAVE_SIZE: u32 = 512;
pub const FXSAVE_ALIGN: u32 = 16;
pub const MAX_THREAD_NAME: u32 = 32;
pub const TLS_MAX_KEYS: u32 = 256;
pub const MIN_DESTRUCT_ITER: u32 = 4;
pub const PRINTK_BUFMAX: u32 = 128;
pub const __GNUC_VA_LIST: u32 = 1;
pub const SERIAL_PRINT_DEBUG_LEVEL: u32 = 10;
pub const APIC_SPUR_INT_VEC: u32 = 255;
pub const APIC_TIMER_INT_VEC: u32 = 240;
pub const APIC_ERROR_INT_VEC: u32 = 241;
pub const APIC_THRML_INT_VEC: u32 = 242;
pub const APIC_PC_INT_VEC: u32 = 243;
pub const APIC_CMCR_INT_VEC: u32 = 244;
pub const APIC_EXT_LVT_DUMMY_VEC: u32 = 245;
pub const APIC_NULL_KICK_VEC: u32 = 252;
pub const APIC_TIMER_DIV: u32 = 16;
pub const APIC_TIMER_DIV_1: u32 = 11;
pub const APIC_TIMER_DIV_2: u32 = 0;
pub const APIC_TIMER_DIV_4: u32 = 1;
pub const APIC_TIMER_DIV_8: u32 = 2;
pub const APIC_TIMER_DIV_16: u32 = 3;
pub const APIC_TIMER_DIV_32: u32 = 8;
pub const APIC_TIMER_DIV_64: u32 = 9;
pub const APIC_TIMER_DIV_128: u32 = 10;
pub const APIC_TIMER_DIVCODE: u32 = 3;
pub const APIC_BASE_MSR: u32 = 27;
pub const IA32_APIC_BASE_MSR_BSP: u32 = 256;
pub const IA32_APIC_BASE_MSR_ENABLE: u32 = 2048;
pub const APIC_BASE_ADDR_MASK: i32 = -4096;
pub const APIC_IPI_SELF: u32 = 262144;
pub const APIC_IPI_ALL: u32 = 524288;
pub const APIC_IPI_OTHERS: u32 = 786432;
pub const APIC_GLOBAL_ENABLE: u32 = 2048;
pub const APIC_SPIV_SW_ENABLE: u32 = 256;
pub const APIC_SPIV_VEC_MASK: u32 = 255;
pub const APIC_SPIV_CORE_FOCUS: u32 = 512;
pub const APIC_SPIC_EOI_BROADCAST_DISABLE: u32 = 4096;
pub const ICR_DEL_MODE_LOWEST: u32 = 256;
pub const ICR_DEL_MODE_SMI: u32 = 512;
pub const ICR_DEL_MODE_NMI: u32 = 1024;
pub const ICR_DEL_MODE_INIT: u32 = 1280;
pub const ICR_DEL_MODE_STARTUP: u32 = 1536;
pub const ICR_DST_MODE_LOG: u32 = 2048;
pub const ICR_SEND_PENDING: u32 = 4096;
pub const ICR_LEVEL_ASSERT: u32 = 16384;
pub const ICR_TRIG_MODE_LEVEL: u32 = 32768;
pub const APIC_ID_SHIFT: u32 = 24;
pub const APIC_ICR2_DST_SHIFT: u32 = 24;
pub const APIC_REG_ID: u32 = 32;
pub const APIC_REG_LVR: u32 = 48;
pub const APIC_REG_TPR: u32 = 128;
pub const APIC_REG_APR: u32 = 144;
pub const APIC_REG_PPR: u32 = 160;
pub const APIC_REG_EOR: u32 = 176;
pub const APIC_REG_RRR: u32 = 192;
pub const APIC_REG_LDR: u32 = 208;
pub const APIC_REG_DFR: u32 = 224;
pub const APIC_REG_SPIV: u32 = 240;
pub const APIC_REG_ISR: u32 = 256;
pub const APIC_REG_TMR: u32 = 384;
pub const APIC_REG_IRR: u32 = 512;
pub const APIC_REG_ESR: u32 = 640;
pub const APIC_REG_LVT_CMCI: u32 = 752;
pub const APIC_REG_ICR: u32 = 768;
pub const APIC_ICR_BUSY: u32 = 4096;
pub const APIC_REG_ICR2: u32 = 784;
pub const APIC_REG_LVTT: u32 = 800;
pub const APIC_REG_LVTTHMR: u32 = 816;
pub const APIC_REG_LVTPC: u32 = 832;
pub const APIC_REG_LVT0: u32 = 848;
pub const APIC_REG_LVT1: u32 = 864;
pub const APIC_REG_LVTERR: u32 = 880;
pub const APIC_REG_TMICT: u32 = 896;
pub const APIC_REG_TMCCT: u32 = 912;
pub const APIC_REG_TMDCR: u32 = 992;
pub const APIC_REG_SELF_IPI: u32 = 1008;
pub const APIC_REG_EXFR: u32 = 1024;
pub const APIC_REG_EXFC: u32 = 1040;
pub const APIC_EXFC_XAIDC_EN: u32 = 4;
pub const APIC_EXFC_SN_EN: u32 = 2;
pub const APIC_EXFC_IERN: u32 = 1;
pub const X2APIC_MSR_ACCESS_BASE: u32 = 2048;
pub const APIC_DEL_MODE_FIXED: u32 = 0;
pub const APIC_DEL_MODE_LOWEST: u32 = 256;
pub const APIC_DEL_MODE_SMI: u32 = 512;
pub const APIC_DEL_MODE_REMRD: u32 = 768;
pub const APIC_DEL_MODE_NMI: u32 = 1024;
pub const APIC_DEL_MODE_INIT: u32 = 1280;
pub const APIC_DEL_MODE_SIPI: u32 = 1536;
pub const APIC_DEL_MODE_EXTINT: u32 = 1792;
pub const APIC_LVT_VEC_MASK: u32 = 255;
pub const APIC_LVT_DISABLED: u32 = 65536;
pub const APIC_DFR_FLAT: u32 = 4294967295;
pub const APIC_DFR_CLUSTER: u32 = 268435455;
pub const APIC_LDR_MASK: u32 = 4278190080;
pub const APIC_ALL_CPUS: u32 = 255;
pub const APIC_TIMER_MASK: u32 = 65536;
pub const APIC_TIMER_ONESHOT: u32 = 0;
pub const APIC_TIMER_PERIODIC: u32 = 131072;
pub const APIC_TIMER_TSCDLINE: u32 = 262144;
pub const IPI_VEC_XCALL: u32 = 243;
pub const MAX_MMAP_ENTRIES: u32 = 128;
pub const AP_TRAMPOLINE_ADDR: u32 = 61440;
pub const AP_BOOT_STACK_ADDR: u32 = 4096;
pub const AP_INFO_AREA: u32 = 8192;
pub const BASE_MEM_LAST_KILO: u32 = 654336;
pub const BIOS_ROM_BASE: u32 = 983040;
pub const BIOS_ROM_END: u32 = 1048575;
pub const KEY_SPECIAL_FLAG: u32 = 256;
pub const KEY_KEYPAD_FLAG: u32 = 512;
pub const KEY_SHIFT_FLAG: u32 = 4096;
pub const KEY_ALT_FLAG: u32 = 8192;
pub const KEY_CTRL_FLAG: u32 = 16384;
pub const KEY_CAPS_FLAG: u32 = 32768;
pub const ASCII_ESC: u32 = 27;
pub const ASCII_BS: u32 = 8;
pub const KEYPAD_START: u32 = 128;
pub const MAX_IOAPICS: u32 = 32;
pub const IOAPIC_DEFAULT_BASE: u32 = 4273995776;
pub const IOREGSEL_REG: u32 = 0;
pub const IOWIN_REG: u32 = 16;
pub const IOAPICID_REG: u32 = 0;
pub const IOAPICVER_REG: u32 = 1;
pub const IOAPICARB_REG: u32 = 2;
pub const IOREDTBL: u32 = 16;
pub const IORED_VEC_MASK: u32 = 65535;
pub const IORED_DEL_MODE_MASK: u32 = 1792;
pub const IORED_DEST_MODE: u32 = 2048;
pub const IORED_DELIVS: u32 = 4096;
pub const IORED_INTPOL: u32 = 8192;
pub const IORED_TRIGGER_MODE: u32 = 32768;
pub const IORED_INT_MASK: u32 = 65536;
pub const DEL_MODE_SHIFT: u32 = 8;
pub const DEST_MODE_SHIFT: u32 = 11;
pub const DELIVS_SHIFT: u32 = 12;
pub const INTPOL_SHIFT: u32 = 13;
pub const TRIG_MODE_SHIFT: u32 = 15;
pub const INT_MASK_SHIFT: u32 = 16;
pub const IORED_DST_MASK_PHY: u32 = 251658240;
pub const IORED_DST_MASK_LOG: u32 = 4278190080;
pub const DELMODE_FIXED: u32 = 0;
pub const DELMODE_LOWEST: u32 = 1;
pub const DELMODE_SMI: u32 = 2;
pub const DELMODE_RSVD: u32 = 3;
pub const DELMODE_NMI: u32 = 4;
pub const DELMODE_INIT: u32 = 5;
pub const DELMODE_RSVD1: u32 = 6;
pub const DELMODE_EXTINT: u32 = 7;
pub const PIN_POLARITY_HI: u32 = 0;
pub const PIN_POLARITY_LO: u32 = 1;
pub const TRIGGER_MODE_EDGE: u32 = 0;
pub const TRIGGER_MODE_LEVEL: u32 = 1;
pub const IOAPIC_MASK_IRQ: u32 = 65536;
pub const NOP_1BYTE: u32 = 144;
pub const NUM_IDT_ENTRIES: u32 = 256;
pub const NUM_EXCEPTIONS: u32 = 32;
pub const DE_EXCP: u32 = 0;
pub const DB_EXCP: u32 = 1;
pub const NMI_INT: u32 = 2;
pub const BP_EXCP: u32 = 3;
pub const OF_EXCP: u32 = 4;
pub const BR_EXCP: u32 = 5;
pub const UD_EXCP: u32 = 6;
pub const NM_EXCP: u32 = 7;
pub const DF_EXCP: u32 = 8;
pub const CP_EXCP: u32 = 9;
pub const TS_EXCP: u32 = 10;
pub const NP_EXCP: u32 = 11;
pub const SS_EXCP: u32 = 12;
pub const GP_EXCP: u32 = 13;
pub const PF_EXCP: u32 = 14;
pub const MF_EXCP: u32 = 16;
pub const AC_EXCP: u32 = 17;
pub const MC_EXCP: u32 = 18;
pub const XM_EXCP: u32 = 19;
pub const VE_EXCP: u32 = 20;
pub const SE_EXCP: u32 = 30;
pub const ERR_CODE_EXCP_MASK: i32 = -4357377;
pub const KERNEL_CS: u32 = 8;
pub const KERNEL_DS: u32 = 16;
pub const KERNEL_SS: u32 = 16;
pub const MEM_ZONE_UC: u32 = 1;
pub const MEM_ZONE_WC: u32 = 2;
pub const MEM_ZONE_WT: u32 = 4;
pub const MEM_ZONE_WB: u32 = 8;
pub const MEM_ZONE_UCE: u32 = 16;
pub const MEM_ZONE_WP: u32 = 4096;
pub const MEM_ZONE_RP: u32 = 8192;
pub const MEM_ZONE_XP: u32 = 16384;
pub const PAGE_SHIFT_4KB: u32 = 12;
pub const PAGE_SHIFT_2MB: u32 = 21;
pub const PAGE_SHIFT_1GB: u32 = 30;
pub const PAGE_SHIFT: u32 = 21;
pub const PAGE_SIZE_4KB: u32 = 4096;
pub const PAGE_SIZE_2MB: u32 = 2097152;
pub const PAGE_SIZE_1GB: u32 = 1073741824;
pub const PAGE_SIZE: u32 = 2097152;
pub const PAGE_MASK: i32 = -2097152;
pub const MEM_1GB: u32 = 1073741824;
pub const MEM_2MB: u32 = 2097152;
pub const NUM_PT_ENTRIES: u32 = 512;
pub const NUM_PD_ENTRIES: u32 = 512;
pub const NUM_PDPT_ENTRIES: u32 = 512;
pub const NUM_PML4_ENTRIES: u32 = 512;
pub const PML4_SHIFT: u32 = 39;
pub const PDPT_SHIFT: u32 = 30;
pub const PD_SHIFT: u32 = 21;
pub const PT_SHIFT: u32 = 12;
pub const PTE_ADDR_MASK: i32 = -4096;
pub const PTE_PRESENT_BIT: u32 = 1;
pub const PTE_WRITABLE_BIT: u32 = 2;
pub const PTE_KERNEL_ONLY_BIT: u32 = 4;
pub const PTE_WRITE_THROUGH_BIT: u32 = 8;
pub const PTE_CACHE_DISABLE_BIT: u32 = 16;
pub const PTE_ACCESSED_BIT: u32 = 32;
pub const PTE_DIRTY_BIT: u32 = 64;
pub const PTE_PAGE_SIZE_BIT: u32 = 128;
pub const PTE_GLOBAL_BIT: u32 = 256;
pub const PTE_PAT_BIT: u32 = 4096;
pub const PTE_NX_BIT: i64 = -9223372036854775808;
pub const HRT_HIHALF_OFFSET: u32 = 0;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const ULLONG_MAX: i32 = -1;
pub const NK_BARRIER_LAST: u32 = 1;
pub const MAX_NUMA_DOMAINS: u32 = 128;
pub const NK_SYS_LEGACY: u32 = 1;
pub type schar_t = ::libc::c_schar;
pub type uchar_t = ::libc::c_uchar;
pub type sshort_t = ::libc::c_short;
pub type ushort_t = ::libc::c_ushort;
pub type sint_t = ::libc::c_int;
pub type uint_t = ::libc::c_uint;
pub type sllong_t = ::libc::c_longlong;
pub type ullong_t = ::libc::c_ulonglong;
pub type slong_t = ::libc::c_long;
pub type ulong_t = ::libc::c_ulong;
pub type off_t = ::libc::c_ulong;
pub type sint64_t = ::libc::c_long;
pub type sint32_t = ::libc::c_int;
pub type sint16_t = ::libc::c_short;
pub type sint8_t = ::libc::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
extern "C" {
    pub fn nk_detect_cpu_freq(arg1: u32) -> ulong_t;
}
extern "C" {
    pub fn nk_is_amd() -> u8;
}
extern "C" {
    pub fn nk_is_intel() -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_regs {
    pub r15: ulong_t,
    pub r14: ulong_t,
    pub r13: ulong_t,
    pub r12: ulong_t,
    pub r11: ulong_t,
    pub r10: ulong_t,
    pub r9: ulong_t,
    pub r8: ulong_t,
    pub rbp: ulong_t,
    pub rdi: ulong_t,
    pub rsi: ulong_t,
    pub rdx: ulong_t,
    pub rcx: ulong_t,
    pub rbx: ulong_t,
    pub rax: ulong_t,
    pub vector: ulong_t,
    pub err_code: ulong_t,
    pub rip: ulong_t,
    pub cs: ulong_t,
    pub rflags: ulong_t,
    pub rsp: ulong_t,
    pub ss: ulong_t,
}
#[test]
fn bindgen_test_layout_nk_regs() {
    assert_eq!(
        ::core::mem::size_of::<nk_regs>(),
        176usize,
        concat!("Size of: ", stringify!(nk_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_regs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r11 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r10 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r9 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r8 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rbp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rdi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rsi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rdx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rcx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rbx as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rax as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).vector as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).err_code as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rip as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rflags as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rsp as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).ss as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(ss)
        )
    );
}
extern "C" {
    pub fn msr_write(msr: u32, data: u64);
}
extern "C" {
    pub fn msr_read(msr: u32) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_hashtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_malloc_data() {
    assert_eq!(
        ::core::mem::size_of::<malloc_data>(),
        40usize,
        concat!("Size of: ", stringify!(malloc_data))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_data>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_free_data() {
    assert_eq!(
        ::core::mem::size_of::<free_data>(),
        40usize,
        concat!("Size of: ", stringify!(free_data))
    );
    assert_eq!(
        ::core::mem::align_of::<free_data>(),
        8usize,
        concat!("Alignment of ", stringify!(free_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_irq_data() {
    assert_eq!(
        ::core::mem::size_of::<irq_data>(),
        40usize,
        concat!("Size of: ", stringify!(irq_data))
    );
    assert_eq!(
        ::core::mem::align_of::<irq_data>(),
        8usize,
        concat!("Alignment of ", stringify!(irq_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_switch_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_thread_switch_data() {
    assert_eq!(
        ::core::mem::size_of::<thread_switch_data>(),
        40usize,
        concat!("Size of: ", stringify!(thread_switch_data))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_switch_data>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_switch_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_instr_data {
    pub func_htable: *mut nk_hashtable,
    pub irqstat: irq_data,
    pub mallocstat: malloc_data,
    pub freestat: free_data,
    pub thr_switch: thread_switch_data,
}
#[test]
fn bindgen_test_layout_nk_instr_data() {
    assert_eq!(
        ::core::mem::size_of::<nk_instr_data>(),
        168usize,
        concat!("Size of: ", stringify!(nk_instr_data))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_instr_data>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_instr_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).func_htable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(func_htable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).irqstat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(irqstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).mallocstat as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(mallocstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).freestat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(freestat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).thr_switch as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(thr_switch)
        )
    );
}
extern "C" {
    pub fn nk_profile_func_enter(func: *const ::libc::c_char);
}
extern "C" {
    pub fn nk_profile_func_exit(func: *const ::libc::c_char);
}
extern "C" {
    pub fn nk_thr_switch_prof_enter();
}
extern "C" {
    pub fn nk_thr_switch_prof_exit();
}
extern "C" {
    pub fn nk_irq_prof_enter();
}
extern "C" {
    pub fn nk_irq_prof_exit();
}
extern "C" {
    pub fn nk_malloc_enter();
}
extern "C" {
    pub fn nk_malloc_exit();
}
extern "C" {
    pub fn nk_free_enter();
}
extern "C" {
    pub fn nk_free_exit();
}
extern "C" {
    pub fn nk_instrument_init();
}
extern "C" {
    pub fn nk_instrument_start();
}
extern "C" {
    pub fn nk_instrument_end();
}
extern "C" {
    pub fn nk_instrument_query();
}
extern "C" {
    pub fn nk_instrument_clear();
}
extern "C" {
    pub fn nk_instrument_calibrate(loops: ::libc::c_uint);
}
pub type spinlock_t = u32;
extern "C" {
    pub fn spinlock_init(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spinlock_deinit(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_nopause(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_irq_save_nopause(lock: *mut spinlock_t) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ctype"]
    pub static mut _ctype: [::libc::c_uchar; 0usize];
}
extern "C" {
    pub fn memcpy(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memcmp(
        s1_: *const ::libc::c_void,
        s2_: *const ::libc::c_void,
        n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memset(dst: *mut ::libc::c_void, c: ::libc::c_char, n: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memmove(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strlen(str: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strnlen(str: *const ::libc::c_char, max: usize) -> usize;
}
extern "C" {
    pub fn strcmp(s1: *const ::libc::c_char, s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp(s1: *const ::libc::c_char, s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncmp(
        s1: *const ::libc::c_char,
        s2: *const ::libc::c_char,
        limit: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        s1: *const ::libc::c_char,
        s2: *const ::libc::c_char,
        limit: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strdup(s: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strpbrk(cs: *const ::libc::c_char, ct: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strptok(cs: *const ::libc::c_char, ct: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strsep(s: *mut *mut ::libc::c_char, ct: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcat(s1: *mut ::libc::c_char, s2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncat(
        s1: *mut ::libc::c_char,
        s2: *const ::libc::c_char,
        limit: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcpy(dest: *mut ::libc::c_char, src: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncpy(
        dest: *mut ::libc::c_char,
        src: *const ::libc::c_char,
        limit: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strchr(s: *const ::libc::c_char, c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strrchr(s: *const ::libc::c_char, c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strspn(s: *const ::libc::c_char, accept: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strcspn(s: *const ::libc::c_char, reject: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strstr(
        haystack: *const ::libc::c_char,
        needle: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn atoi(buf: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strtoi(nptr: *const ::libc::c_char, endptr: *mut *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strtol(
        str: *const ::libc::c_char,
        endptr: *mut *mut ::libc::c_char,
        base: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn atol(nptr: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn atox(buf: *const ::libc::c_char) -> u64;
}
extern "C" {
    pub fn strtox(nptr: *const ::libc::c_char, endptr: *mut *mut ::libc::c_char) -> u64;
}
extern "C" {
    pub fn str_toupper(s: *mut ::libc::c_char);
}
extern "C" {
    pub fn str_tolower(s: *mut ::libc::c_char);
}
extern "C" {
    pub fn ultoa(
        x: ::libc::c_ulong,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ltoa(
        x: ::libc::c_long,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn utoa(
        x: ::libc::c_uint,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn itoa(
        x: ::libc::c_int,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ustoa(
        x: ::libc::c_ushort,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn stoa(
        x: ::libc::c_short,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn uctoa(
        x: ::libc::c_uchar,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ctoa(
        x: ::libc::c_char,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn dtoa_r(
        x: f64,
        mode: ::libc::c_int,
        ndigits: ::libc::c_int,
        decpt: *mut ::libc::c_int,
        sign: *mut ::libc::c_int,
        rve: *mut *mut ::libc::c_char,
        buf: *mut ::libc::c_char,
        blen: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn dtoa_printf_helper(
        x: f64,
        pf_mode: ::libc::c_char,
        ndigits: ::libc::c_int,
        prec: ::libc::c_int,
        buf: *mut ::libc::c_char,
        blen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strtod(s: *const ::libc::c_char, se: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn strtok(s: *mut ::libc::c_char, delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::core::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::core::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_queue {
    pub queue: list_head,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_nk_queue() {
    assert_eq!(
        ::core::mem::size_of::<nk_queue>(),
        24usize,
        concat!("Size of: ", stringify!(nk_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_queue>())).queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_queue),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_queue>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_queue),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_queue_entry {
    pub node: list_head,
}
#[test]
fn bindgen_test_layout_nk_queue_entry() {
    assert_eq!(
        ::core::mem::size_of::<nk_queue_entry>(),
        16usize,
        concat!("Size of: ", stringify!(nk_queue_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_queue_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_queue_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_queue_entry>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_queue_entry),
            "::",
            stringify!(node)
        )
    );
}
pub type nk_queue_t = nk_queue;
pub type nk_queue_entry_t = nk_queue_entry;
extern "C" {
    pub fn nk_queue_create() -> *mut nk_queue_t;
}
extern "C" {
    pub fn nk_queue_destroy(q: *mut nk_queue_t, free_entries: u8);
}
pub type nk_cache_part_thread_state_t = u16;
pub type nk_stack_size_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_sched_config {
    pub util_limit: u64,
    pub sporadic_reservation: u64,
    pub aperiodic_reservation: u64,
    pub aperiodic_quantum: u64,
    pub aperiodic_default_priority: u64,
}
#[test]
fn bindgen_test_layout_nk_sched_config() {
    assert_eq!(
        ::core::mem::size_of::<nk_sched_config>(),
        40usize,
        concat!("Size of: ", stringify!(nk_sched_config))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_sched_config>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_sched_config))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_sched_config>())).util_limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_config),
            "::",
            stringify!(util_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_config>())).sporadic_reservation as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_config),
            "::",
            stringify!(sporadic_reservation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_config>())).aperiodic_reservation as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_config),
            "::",
            stringify!(aperiodic_reservation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_config>())).aperiodic_quantum as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_config),
            "::",
            stringify!(aperiodic_quantum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_config>())).aperiodic_default_priority as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_config),
            "::",
            stringify!(aperiodic_default_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_sched_periodic_constraints {
    pub phase: u64,
    pub period: u64,
    pub slice: u64,
}
#[test]
fn bindgen_test_layout_nk_sched_periodic_constraints() {
    assert_eq!(
        ::core::mem::size_of::<nk_sched_periodic_constraints>(),
        24usize,
        concat!("Size of: ", stringify!(nk_sched_periodic_constraints))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_sched_periodic_constraints>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_sched_periodic_constraints))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_periodic_constraints>())).phase as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_periodic_constraints),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_periodic_constraints>())).period as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_periodic_constraints),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_periodic_constraints>())).slice as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_periodic_constraints),
            "::",
            stringify!(slice)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_sched_sporadic_constraints {
    pub phase: u64,
    pub size: u64,
    pub deadline: u64,
    pub aperiodic_priority: u64,
}
#[test]
fn bindgen_test_layout_nk_sched_sporadic_constraints() {
    assert_eq!(
        ::core::mem::size_of::<nk_sched_sporadic_constraints>(),
        32usize,
        concat!("Size of: ", stringify!(nk_sched_sporadic_constraints))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_sched_sporadic_constraints>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_sched_sporadic_constraints))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_sporadic_constraints>())).phase as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_sporadic_constraints),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_sporadic_constraints>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_sporadic_constraints),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_sporadic_constraints>())).deadline as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_sporadic_constraints),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_sporadic_constraints>())).aperiodic_priority
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_sporadic_constraints),
            "::",
            stringify!(aperiodic_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_sched_aperiodic_constraints {
    pub priority: u64,
}
#[test]
fn bindgen_test_layout_nk_sched_aperiodic_constraints() {
    assert_eq!(
        ::core::mem::size_of::<nk_sched_aperiodic_constraints>(),
        8usize,
        concat!("Size of: ", stringify!(nk_sched_aperiodic_constraints))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_sched_aperiodic_constraints>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_sched_aperiodic_constraints))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_aperiodic_constraints>())).priority as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_aperiodic_constraints),
            "::",
            stringify!(priority)
        )
    );
}
pub const nk_sched_constraint_type_t_APERIODIC: nk_sched_constraint_type_t = 0;
pub const nk_sched_constraint_type_t_SPORADIC: nk_sched_constraint_type_t = 1;
pub const nk_sched_constraint_type_t_PERIODIC: nk_sched_constraint_type_t = 2;
pub type nk_sched_constraint_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nk_sched_constraints {
    pub type_: nk_sched_constraint_type_t,
    pub interrupt_priority_class: u8,
    pub __bindgen_anon_1: nk_sched_constraints__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nk_sched_constraints__bindgen_ty_1 {
    pub periodic: nk_sched_periodic_constraints,
    pub sporadic: nk_sched_sporadic_constraints,
    pub aperiodic: nk_sched_aperiodic_constraints,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_nk_sched_constraints__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nk_sched_constraints__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(nk_sched_constraints__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_sched_constraints__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nk_sched_constraints__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_constraints__bindgen_ty_1>())).periodic as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_constraints__bindgen_ty_1),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_constraints__bindgen_ty_1>())).sporadic as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_constraints__bindgen_ty_1),
            "::",
            stringify!(sporadic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_constraints__bindgen_ty_1>())).aperiodic as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_constraints__bindgen_ty_1),
            "::",
            stringify!(aperiodic)
        )
    );
}
#[test]
fn bindgen_test_layout_nk_sched_constraints() {
    assert_eq!(
        ::core::mem::size_of::<nk_sched_constraints>(),
        40usize,
        concat!("Size of: ", stringify!(nk_sched_constraints))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_sched_constraints>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_sched_constraints))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_sched_constraints>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_constraints),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nk_sched_constraints>())).interrupt_priority_class as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_sched_constraints),
            "::",
            stringify!(interrupt_priority_class)
        )
    );
}
extern "C" {
    pub fn nk_sched_init(cfg: *mut nk_sched_config) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_init_ap(cfg: *mut nk_sched_config) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_start();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_sched_thread_state {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nk_sched_thread_state_init(
        thread: *mut nk_thread,
        constraints: *mut nk_sched_constraints,
    ) -> *mut nk_sched_thread_state;
}
extern "C" {
    pub fn nk_sched_thread_state_deinit(thread: *mut nk_thread);
}
extern "C" {
    pub fn nk_sched_initial_placement() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_thread_post_create(thread: *mut nk_thread) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_thread_pre_destroy(thread: *mut nk_thread) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_thread_change_constraints(
        constraints: *mut nk_sched_constraints,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_thread_move(
        thread: *mut nk_thread,
        new_cpu: ::libc::c_int,
        block: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_cpu_mug(cpu: ::libc::c_int, max: u64, actual: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_make_runnable(
        thread: *mut nk_thread,
        cpu: ::libc::c_int,
        admit: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_sched_kick_cpu(cpu: ::libc::c_int);
}
extern "C" {
    pub fn nk_sched_sleep(lock_to_release: *mut spinlock_t);
}
extern "C" {
    pub fn nk_sched_yield(lock_to_release: *mut spinlock_t);
}
extern "C" {
    pub fn nk_sched_exit(lock_to_release: *mut spinlock_t);
}
extern "C" {
    pub fn nk_sched_reap(unconditional: ::libc::c_int);
}
extern "C" {
    pub fn nk_sched_reanimate(
        min_stack_size: nk_stack_size_t,
        placement_cpu: ::libc::c_int,
    ) -> *mut nk_thread;
}
extern "C" {
    pub fn nk_sched_get_realtime() -> u64;
}
extern "C" {
    pub fn nk_sched_dump_threads(cpu: ::libc::c_int);
}
extern "C" {
    pub fn nk_sched_dump_cores(cpu: ::libc::c_int);
}
extern "C" {
    pub fn nk_sched_dump_time(cpu: ::libc::c_int);
}
extern "C" {
    pub fn nk_sched_map_threads(
        cpu: ::libc::c_int,
        func: ::core::option::Option<
            unsafe extern "C" fn(t: *mut nk_thread, state: *mut ::libc::c_void),
        >,
        state: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn nk_sched_stop_world();
}
extern "C" {
    pub fn nk_sched_get_cur_thread_on_cpu(cpu: ::libc::c_int) -> *mut nk_thread;
}
extern "C" {
    pub fn nk_sched_start_world();
}
extern "C" {
    pub fn nk_sched_need_resched() -> *mut nk_thread;
}
extern "C" {
    pub fn nk_sched_get_runtime(t: *mut nk_thread) -> u64;
}
extern "C" {
    pub fn nk_sched_thread_get_constraints(
        t: *mut nk_thread,
        c: *mut nk_sched_constraints,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_find_thread_by_tid(tid: u64) -> *mut nk_thread;
}
#[doc = " EXTERNAL INTERFACE"]
pub type nk_thread_id_t = *mut ::libc::c_void;
pub type nk_thread_fun_t = ::core::option::Option<
    unsafe extern "C" fn(input: *mut ::libc::c_void, output: *mut *mut ::libc::c_void),
>;
extern "C" {
    pub fn set_vc_for_rust();
}
extern "C" {
    pub fn nk_thread_create(
        fun: nk_thread_fun_t,
        input: *mut ::libc::c_void,
        output: *mut *mut ::libc::c_void,
        is_detached: u8,
        stack_size: nk_stack_size_t,
        tid: *mut nk_thread_id_t,
        bound_cpu: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_thread_run(tid: nk_thread_id_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_thread_start(
        fun: nk_thread_fun_t,
        input: *mut ::libc::c_void,
        output: *mut *mut ::libc::c_void,
        is_detached: u8,
        stack_size: nk_stack_size_t,
        tid: *mut nk_thread_id_t,
        bound_cpu: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_thread_fork() -> nk_thread_id_t;
}
extern "C" {
    pub fn nk_set_thread_output(result: *mut ::libc::c_void);
}
extern "C" {
    pub fn nk_thread_name(tid: nk_thread_id_t, name: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_yield();
}
extern "C" {
    pub fn nk_join(t: nk_thread_id_t, retval: *mut *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_join_all_children(
        output_consumer: ::core::option::Option<
            unsafe extern "C" fn(output: *mut ::libc::c_void) -> ::libc::c_int,
        >,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_thread_exit(retval: *mut ::libc::c_void);
}
extern "C" {
    pub fn nk_thread_destroy(t: nk_thread_id_t);
}
extern "C" {
    pub fn nk_get_tid() -> nk_thread_id_t;
}
extern "C" {
    pub fn nk_get_parent_tid() -> nk_thread_id_t;
}
pub type nk_tls_key_t = ::libc::c_uint;
extern "C" {
    pub fn nk_tls_key_create(
        key: *mut nk_tls_key_t,
        destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_tls_key_delete(key: nk_tls_key_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_tls_get(key: nk_tls_key_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn nk_tls_set(key: nk_tls_key_t, val: *const ::libc::c_void) -> ::libc::c_int;
}
pub const nk_thread_status_t_NK_THR_INIT: nk_thread_status_t = 0;
pub const nk_thread_status_t_NK_THR_RUNNING: nk_thread_status_t = 1;
pub const nk_thread_status_t_NK_THR_WAITING: nk_thread_status_t = 2;
pub const nk_thread_status_t_NK_THR_SUSPENDED: nk_thread_status_t = 3;
pub const nk_thread_status_t_NK_THR_EXITED: nk_thread_status_t = 4;
pub type nk_thread_status_t = u32;
pub type nk_thread_queue_t = nk_queue;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct nk_thread {
    pub rsp: u64,
    pub stack: *mut ::libc::c_void,
    pub fpu_state_offset: u16,
    pub cache_part_state: nk_cache_part_thread_state_t,
    pub stack_size: nk_stack_size_t,
    pub tid: ::libc::c_ulong,
    pub lock: ::libc::c_int,
    pub runq_node: nk_queue_entry_t,
    pub thr_list_node: nk_queue_entry_t,
    pub parent: *mut nk_thread,
    pub children: list_head,
    pub child_node: list_head,
    pub refcount: ::libc::c_ulong,
    pub waitq: *mut nk_thread_queue_t,
    pub wait_node: nk_queue_entry_t,
    pub status: nk_thread_status_t,
    pub bound_cpu: ::libc::c_int,
    pub placement_cpu: ::libc::c_int,
    pub current_cpu: ::libc::c_int,
    pub is_idle: u8,
    pub output_loc: *mut *mut ::libc::c_void,
    pub output: *mut ::libc::c_void,
    pub input: *mut ::libc::c_void,
    pub fun: nk_thread_fun_t,
    pub sched_state: *mut nk_sched_thread_state,
    pub vc: *mut nk_virtual_console,
    pub name: [::libc::c_char; 32usize],
    pub tls: [*const ::libc::c_void; 256usize],
    pub fpu_state: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_nk_thread() {
    assert_eq!(
        ::core::mem::size_of::<nk_thread>(),
        6400usize,
        concat!("Size of: ", stringify!(nk_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_thread>(),
        64usize,
        concat!("Alignment of ", stringify!(nk_thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).fpu_state_offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(fpu_state_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).cache_part_state as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(cache_part_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).stack_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).tid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).lock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).runq_node as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(runq_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).thr_list_node as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(thr_list_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).parent as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).children as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).child_node as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(child_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).refcount as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).waitq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(waitq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).wait_node as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(wait_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).status as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).bound_cpu as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(bound_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).placement_cpu as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(placement_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).current_cpu as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(current_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).is_idle as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(is_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).output_loc as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(output_loc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).output as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).input as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).fun as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(fun)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).sched_state as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(sched_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).vc as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(vc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).name as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).tls as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_thread>())).fpu_state as *const _ as usize },
        2304usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_thread),
            "::",
            stringify!(fpu_state)
        )
    );
}
pub type nk_thread_t = nk_thread;
extern "C" {
    pub fn __thread_fork() -> nk_thread_id_t;
}
extern "C" {
    pub fn _nk_thread_init(
        t: *mut nk_thread_t,
        stack: *mut ::libc::c_void,
        is_detached: u8,
        bound_cpu: ::libc::c_int,
        placement_cpu: ::libc::c_int,
        parent: *mut nk_thread_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_thread_queue_create() -> *mut nk_thread_queue_t;
}
extern "C" {
    pub fn nk_thread_queue_destroy(q: *mut nk_thread_queue_t);
}
extern "C" {
    pub fn nk_thread_queue_sleep(q: *mut nk_thread_queue_t);
}
extern "C" {
    pub fn nk_thread_queue_sleep_extended(
        q: *mut nk_thread_queue_t,
        cond_check: ::core::option::Option<
            unsafe extern "C" fn(state: *mut ::libc::c_void) -> ::libc::c_int,
        >,
        state: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn nk_thread_queue_wake_one(q: *mut nk_thread_queue_t);
}
extern "C" {
    pub fn nk_thread_queue_wake_all(q: *mut nk_thread_queue_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_tls {
    pub seq_num: ::libc::c_uint,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
}
#[test]
fn bindgen_test_layout_nk_tls() {
    assert_eq!(
        ::core::mem::size_of::<nk_tls>(),
        16usize,
        concat!("Size of: ", stringify!(nk_tls))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_tls>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_tls))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_tls>())).seq_num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_tls),
            "::",
            stringify!(seq_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_tls>())).destructor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_tls),
            "::",
            stringify!(destructor)
        )
    );
}
extern "C" {
    pub fn nk_tls_test();
}
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn panic(fmt: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn printk(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vprintk(fmt: *const ::libc::c_char, args: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn early_printk(fmt: *const ::libc::c_char, args: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn simple_strtoul(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn simple_strtol(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn simple_strtoull(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_longlong;
}
extern "C" {
    pub fn strict_strtoul(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strict_strtol(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_long,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strict_strtoull(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_ulonglong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strict_strtoll(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_longlong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut ::libc::c_char,
        size: ::libc::c_ulong,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vscnprintf(
        buf: *mut ::libc::c_char,
        size: usize,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut ::libc::c_char,
        size: ::libc::c_ulong,
        fmt: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn scnprintf(
        buf: *mut ::libc::c_char,
        size: usize,
        fmt: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut ::libc::c_char,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::libc::c_char, fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        buf: *const ::libc::c_char,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sscanf(buf: *const ::libc::c_char, fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn warn_slowpath(
        file: *const ::libc::c_char,
        line: ::libc::c_int,
        fmt: *const ::libc::c_char,
        ...
    );
}
extern "C" {
    pub fn serial_putchar(c: ::libc::c_uchar);
}
extern "C" {
    pub fn serial_write(buf: *const ::libc::c_char);
}
extern "C" {
    pub fn serial_puts(buf: *const ::libc::c_char);
}
extern "C" {
    pub fn serial_print(format: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn serial_printlevel(level: ::libc::c_int, format: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn serial_print_poll(format: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn serial_early_init();
}
extern "C" {
    pub fn serial_init();
}
extern "C" {
    #[doc = " EXTERNAL INTERFACE"]
    pub fn nk_get_num_cpus() -> u32;
}
extern "C" {
    pub fn nk_get_cpu_by_lapicid(lapicid: u8) -> u8;
}
pub const apic_mode_t_APIC_INVALID: apic_mode_t = 0;
pub const apic_mode_t_APIC_DISABLED: apic_mode_t = 1;
pub const apic_mode_t_APIC_XAPIC: apic_mode_t = 2;
pub const apic_mode_t_APIC_X2APIC: apic_mode_t = 3;
pub type apic_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apic_dev {
    pub mode: apic_mode_t,
    pub base_addr: ulong_t,
    pub version: u8,
    pub id: uint_t,
    pub spur_int_cnt: u64,
    pub err_int_cnt: u64,
    pub bus_freq_hz: u64,
    pub ps_per_tick: u64,
    pub cycles_per_us: u64,
    pub cycles_per_tick: u64,
    pub timer_set: u8,
    pub current_ticks: u32,
    pub timer_count: u64,
    pub in_timer_interrupt: ::libc::c_int,
    pub in_kick_interrupt: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_apic_dev() {
    assert_eq!(
        ::core::mem::size_of::<apic_dev>(),
        96usize,
        concat!("Size of: ", stringify!(apic_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<apic_dev>(),
        8usize,
        concat!("Alignment of ", stringify!(apic_dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).base_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).spur_int_cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(spur_int_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).err_int_cnt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(err_int_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).bus_freq_hz as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(bus_freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).ps_per_tick as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(ps_per_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).cycles_per_us as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(cycles_per_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).cycles_per_tick as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(cycles_per_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).timer_set as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(timer_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).current_ticks as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(current_ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).timer_count as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(timer_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).in_timer_interrupt as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(in_timer_interrupt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).in_kick_interrupt as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(in_kick_interrupt)
        )
    );
}
extern "C" {
    pub fn apic_get_id(apic: *mut apic_dev) -> u32;
}
extern "C" {
    pub fn apic_do_eoi();
}
extern "C" {
    pub fn apic_self_ipi(apic: *mut apic_dev, vector: uint_t);
}
extern "C" {
    pub fn apic_send_iipi(apic: *mut apic_dev, remote_id: u32);
}
extern "C" {
    pub fn apic_deinit_iipi(apic: *mut apic_dev, remote_id: u32);
}
extern "C" {
    pub fn apic_send_sipi(apic: *mut apic_dev, remote_id: u32, target: u8);
}
extern "C" {
    pub fn apic_bcast_iipi(apic: *mut apic_dev);
}
extern "C" {
    pub fn apic_bcast_deinit_iipi(apic: *mut apic_dev);
}
extern "C" {
    pub fn apic_bcast_sipi(apic: *mut apic_dev, target: u8);
}
extern "C" {
    pub fn apic_init(core: *mut cpu);
}
extern "C" {
    pub fn apic_get_maxlvt(apic: *mut apic_dev) -> ::libc::c_int;
}
extern "C" {
    pub fn apic_read_timer(apic: *mut apic_dev) -> ::libc::c_int;
}
extern "C" {
    pub fn apic_wait_for_send(apic: *mut apic_dev) -> u32;
}
extern "C" {
    pub fn apic_cycles_to_ticks(apic: *mut apic_dev, cycles: u64) -> u32;
}
extern "C" {
    pub fn apic_realtime_to_ticks(apic: *mut apic_dev, ns: u64) -> u32;
}
extern "C" {
    pub fn apic_realtime_to_cycles(apic: *mut apic_dev, ns: u64) -> u64;
}
extern "C" {
    pub fn apic_cycles_to_realtime(apic: *mut apic_dev, cycles: u64) -> u64;
}
extern "C" {
    pub fn apic_set_oneshot_timer(apic: *mut apic_dev, ticks: u32);
}
pub const nk_timer_condition_t_UNCOND: nk_timer_condition_t = 0;
pub const nk_timer_condition_t_IF_EARLIER: nk_timer_condition_t = 1;
pub const nk_timer_condition_t_IF_LATER: nk_timer_condition_t = 2;
pub type nk_timer_condition_t = u32;
extern "C" {
    pub fn apic_update_oneshot_timer(apic: *mut apic_dev, ticks: u32, cond: nk_timer_condition_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buddy_mempool {
    pub base_addr: ulong_t,
    #[doc = " base address of the memory pool"]
    pub pool_order: ulong_t,
    #[doc = " size of memory pool = 2^pool_order"]
    pub min_order: ulong_t,
    #[doc = " minimum allocatable block size"]
    pub num_blocks: ulong_t,
    #[doc = " number of bits in tag_bits"]
    pub tag_bits: *mut ulong_t,
    #[doc = " one bit for each 2^min_order block"]
    #[doc = "   0 = block is allocated"]
    #[doc = "   1 = block is available"]
    pub avail: *mut list_head,
    #[doc = " one free list for each block size,"]
    #[doc = " indexed by block order:"]
    #[doc = "   avail[i] = free list of 2^i blocks"]
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_buddy_mempool() {
    assert_eq!(
        ::core::mem::size_of::<buddy_mempool>(),
        56usize,
        concat!("Size of: ", stringify!(buddy_mempool))
    );
    assert_eq!(
        ::core::mem::align_of::<buddy_mempool>(),
        8usize,
        concat!("Alignment of ", stringify!(buddy_mempool))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).base_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).pool_order as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(pool_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).min_order as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(min_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).num_blocks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).tag_bits as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(tag_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).avail as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    pub fn buddy_init(
        base_addr: ulong_t,
        pool_order: ulong_t,
        min_order: ulong_t,
    ) -> *mut buddy_mempool;
}
extern "C" {
    pub fn buddy_free(mp: *mut buddy_mempool, addr: *mut ::libc::c_void, order: ulong_t);
}
extern "C" {
    pub fn buddy_alloc(mp: *mut buddy_mempool, order: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn buddy_sanity_check(mp: *mut buddy_mempool) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buddy_pool_stats {
    pub start_addr: *mut ::libc::c_void,
    pub end_addr: *mut ::libc::c_void,
    pub total_blocks_free: u64,
    pub total_bytes_free: u64,
    pub min_alloc_size: u64,
    pub max_alloc_size: u64,
}
#[test]
fn bindgen_test_layout_buddy_pool_stats() {
    assert_eq!(
        ::core::mem::size_of::<buddy_pool_stats>(),
        48usize,
        concat!("Size of: ", stringify!(buddy_pool_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<buddy_pool_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(buddy_pool_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_pool_stats>())).start_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(start_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_pool_stats>())).end_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(end_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).total_blocks_free as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(total_blocks_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).total_bytes_free as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(total_bytes_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).min_alloc_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(min_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).max_alloc_size as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(max_alloc_size)
        )
    );
}
extern "C" {
    pub fn buddy_stats(mp: *mut buddy_mempool, stats: *mut buddy_pool_stats);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_map_entry {
    pub addr: u64,
    pub len: u64,
    pub type_: u32,
}
#[test]
fn bindgen_test_layout_mem_map_entry() {
    assert_eq!(
        ::core::mem::size_of::<mem_map_entry>(),
        24usize,
        concat!("Size of: ", stringify!(mem_map_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_map_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_map_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_map_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_map_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_map_entry>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_map_entry),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_map_entry>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_map_entry),
            "::",
            stringify!(type_)
        )
    );
}
pub type mem_map_entry_t = mem_map_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmap_info {
    pub usable_ram: u64,
    pub total_mem: u64,
    pub last_pfn: u32,
    pub num_regions: u32,
}
#[test]
fn bindgen_test_layout_mmap_info() {
    assert_eq!(
        ::core::mem::size_of::<mmap_info>(),
        24usize,
        concat!("Size of: ", stringify!(mmap_info))
    );
    assert_eq!(
        ::core::mem::align_of::<mmap_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mmap_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).usable_ram as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(usable_ram)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).total_mem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(total_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).last_pfn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(last_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).num_regions as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(num_regions)
        )
    );
}
pub type mmap_info_t = mmap_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct boot_mem_info {
    pub page_map: *mut ulong_t,
    pub npages: ulong_t,
    pub pm_len: ulong_t,
    pub last_offset: ulong_t,
    pub last_pos: ulong_t,
    pub last_success: ulong_t,
}
#[test]
fn bindgen_test_layout_boot_mem_info() {
    assert_eq!(
        ::core::mem::size_of::<boot_mem_info>(),
        48usize,
        concat!("Size of: ", stringify!(boot_mem_info))
    );
    assert_eq!(
        ::core::mem::align_of::<boot_mem_info>(),
        8usize,
        concat!("Alignment of ", stringify!(boot_mem_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).page_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(page_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).npages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).pm_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(pm_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).last_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(last_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).last_pos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(last_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).last_success as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(last_success)
        )
    );
}
pub type boot_mem_info_t = boot_mem_info;
extern "C" {
    pub fn mm_boot_get_region(i: ::libc::c_uint) -> *mut mem_map_entry;
}
extern "C" {
    pub fn mm_boot_num_regions() -> ::libc::c_uint;
}
extern "C" {
    pub fn mm_get_usable_ram() -> u64;
}
extern "C" {
    pub fn mm_get_all_mem() -> u64;
}
extern "C" {
    pub fn mm_boot_last_pfn() -> ulong_t;
}
extern "C" {
    pub fn mm_boot_init(mbd: ulong_t) -> ::libc::c_int;
}
extern "C" {
    pub fn mm_boot_kmem_init();
}
extern "C" {
    pub fn mm_boot_kmem_cleanup();
}
extern "C" {
    pub fn mm_dump_page_map();
}
extern "C" {
    pub fn mm_boot_reserve_mem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn mm_boot_reserve_vmem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn mm_boot_free_mem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn mm_boot_free_vmem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn __mm_boot_alloc(size: ulong_t, align: ulong_t, goal: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mm_boot_alloc(size: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mm_boot_alloc_aligned(size: ulong_t, align: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mm_boot_free(addr: *mut ::libc::c_void, size: ulong_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_data {
    pub ordered_regions: list_head,
}
#[test]
fn bindgen_test_layout_kmem_data() {
    assert_eq!(
        ::core::mem::size_of::<kmem_data>(),
        16usize,
        concat!("Size of: ", stringify!(kmem_data))
    );
    assert_eq!(
        ::core::mem::align_of::<kmem_data>(),
        8usize,
        concat!("Alignment of ", stringify!(kmem_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_data>())).ordered_regions as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_data),
            "::",
            stringify!(ordered_regions)
        )
    );
}
extern "C" {
    pub fn nk_kmem_init() -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_get_base_zone() -> *mut mem_region;
}
extern "C" {
    pub fn kmem_get_region_by_addr(addr: ulong_t) -> *mut mem_region;
}
extern "C" {
    pub fn kmem_add_memory(mem: *mut mem_region, base_addr: ulong_t, size: usize);
}
extern "C" {
    pub fn kmem_inform_boot_allocation(low: *mut ::libc::c_void, high: *mut ::libc::c_void);
}
extern "C" {
    pub fn kmem_malloc_specific(
        size: usize,
        cpu: ::libc::c_int,
        zero: ::libc::c_int,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_malloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_mallocz(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_realloc(ptr: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_free(addr: *mut ::libc::c_void);
}
extern "C" {
    pub fn kmem_find_block(
        any_addr: *mut ::libc::c_void,
        block_addr: *mut *mut ::libc::c_void,
        block_size: *mut u64,
        flags: *mut u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_set_block_flags(block_addr: *mut ::libc::c_void, flags: u64) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_mask_all_blocks_flags(mask: u64, ormask: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_get_internal_pointer_range(
        start: *mut *mut ::libc::c_void,
        end: *mut *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn kmem_apply_to_matching_blocks(
        mask: u64,
        flags: u64,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                block: *mut ::libc::c_void,
                state: *mut ::libc::c_void,
            ) -> ::libc::c_int,
        >,
        state: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_sanity_check() -> ::libc::c_int;
}
extern "C" {
    pub fn arch_detect_mem_map(
        mm_info: *mut mmap_info_t,
        memory_map: *mut mem_map_entry_t,
        mbd: ::libc::c_ulong,
    );
}
extern "C" {
    pub fn arch_reserve_boot_regions(mbd: ::libc::c_ulong);
}
#[repr(C)]
#[derive(Debug)]
pub struct kmem_stats {
    pub total_num_pools: u64,
    pub total_blocks_free: u64,
    pub total_bytes_free: u64,
    pub min_alloc_size: u64,
    pub max_alloc_size: u64,
    pub max_pools: u64,
    pub num_pools: u64,
    pub pool_stats: __IncompleteArrayField<buddy_pool_stats>,
}
#[test]
fn bindgen_test_layout_kmem_stats() {
    assert_eq!(
        ::core::mem::size_of::<kmem_stats>(),
        56usize,
        concat!("Size of: ", stringify!(kmem_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<kmem_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(kmem_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).total_num_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(total_num_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).total_blocks_free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(total_blocks_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).total_bytes_free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(total_bytes_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).min_alloc_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(min_alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).max_alloc_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(max_alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).max_pools as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(max_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).num_pools as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(num_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).pool_stats as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(pool_stats)
        )
    );
}
extern "C" {
    pub fn kmem_num_pools() -> u64;
}
extern "C" {
    pub fn kmem_stats(stats: *mut kmem_stats);
}
pub type nk_xcall_func_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void)>;
pub type cpu_id_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_xcall {
    pub xcall_node: nk_queue_entry_t,
    pub data: *mut ::libc::c_void,
    pub fun: nk_xcall_func_t,
    pub xcall_done: u8,
    pub has_waiter: u8,
}
#[test]
fn bindgen_test_layout_nk_xcall() {
    assert_eq!(
        ::core::mem::size_of::<nk_xcall>(),
        40usize,
        concat!("Size of: ", stringify!(nk_xcall))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_xcall>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_xcall))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).xcall_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(xcall_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).fun as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(fun)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).xcall_done as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(xcall_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).has_waiter as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(has_waiter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu {
    pub cur_thread: *mut nk_thread,
    pub interrupt_nesting_level: u16,
    pub preempt_disable_level: u16,
    pub interrupt_count: u64,
    pub exception_count: u64,
    pub id: cpu_id_t,
    pub lapic_id: u32,
    pub enabled: u8,
    pub is_bsp: u8,
    pub cpu_sig: u32,
    pub feat_flags: u32,
    pub booted: u8,
    pub apic: *mut apic_dev,
    pub system: *mut sys_info,
    pub lock: spinlock_t,
    pub sched_state: *mut nk_sched_percpu_state,
    pub xcall_q: *mut nk_queue_t,
    pub xcall_nowait_info: nk_xcall,
    pub cpu_khz: ulong_t,
    pub tp: *mut nk_topo_params,
    pub coord: *mut nk_cpu_coords,
    pub domain: *mut numa_domain,
    pub kmem: kmem_data,
    pub rand: *mut nk_rand_info,
}
#[test]
fn bindgen_test_layout_cpu() {
    assert_eq!(
        ::core::mem::size_of::<cpu>(),
        192usize,
        concat!("Size of: ", stringify!(cpu))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).cur_thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(cur_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).interrupt_nesting_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(interrupt_nesting_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).preempt_disable_level as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(preempt_disable_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).interrupt_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(interrupt_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).exception_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(exception_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).id as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).lapic_id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(lapic_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).enabled as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).is_bsp as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(is_bsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).cpu_sig as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(cpu_sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).feat_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(feat_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).booted as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(booted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).apic as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(apic))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).system as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(system)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).lock as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(lock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).sched_state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(sched_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).xcall_q as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(xcall_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).xcall_nowait_info as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(xcall_nowait_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).cpu_khz as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(cpu_khz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).tp as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(tp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).coord as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(coord)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).domain as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).kmem as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(kmem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).rand as *const _ as usize },
        184usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(rand))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ap_init_area {
    pub stack: u32,
    pub rsvd: u32,
    pub gdt: [u32; 6usize],
    pub gdt_limit: u16,
    pub gdt_base: u32,
    pub rsvd1: u16,
    pub gdt64: [u64; 3usize],
    pub gdt64_limit: u16,
    pub gdt64_base: u64,
    pub cr3: u64,
    pub cpu_ptr: *mut cpu,
    pub entry: ::core::option::Option<unsafe extern "C" fn(core: *mut cpu)>,
}
#[test]
fn bindgen_test_layout_ap_init_area() {
    assert_eq!(
        ::core::mem::size_of::<ap_init_area>(),
        98usize,
        concat!("Size of: ", stringify!(ap_init_area))
    );
    assert_eq!(
        ::core::mem::align_of::<ap_init_area>(),
        1usize,
        concat!("Alignment of ", stringify!(ap_init_area))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).rsvd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt_limit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt_base as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).rsvd1 as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(rsvd1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt64 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt64_limit as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt64_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt64_base as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt64_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).cr3 as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).cpu_ptr as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(cpu_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).entry as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    pub fn smp_early_init(naut: *mut naut_info) -> ::libc::c_int;
}
extern "C" {
    pub fn smp_bringup_aps(naut: *mut naut_info) -> ::libc::c_int;
}
extern "C" {
    pub fn smp_xcall(
        cpu_id: cpu_id_t,
        fun: nk_xcall_func_t,
        arg: *mut ::libc::c_void,
        wait: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn smp_ap_entry(core: *mut cpu);
}
extern "C" {
    pub fn smp_setup_xcall_bsp(core: *mut cpu) -> ::libc::c_int;
}
extern "C" {
    pub fn arch_early_init(naut: *mut naut_info) -> ::libc::c_int;
}
pub type nk_keycode_t = u16;
pub type nk_scancode_t = u16;
extern "C" {
    pub fn kbd_translate(arg1: nk_scancode_t) -> nk_keycode_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_mouse_event {
    pub left: u8,
    pub middle: u8,
    pub right: u8,
    pub res: u8,
    pub dx: sint32_t,
    pub dy: sint32_t,
}
#[test]
fn bindgen_test_layout_nk_mouse_event() {
    assert_eq!(
        ::core::mem::size_of::<nk_mouse_event>(),
        12usize,
        concat!("Size of: ", stringify!(nk_mouse_event))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_mouse_event>(),
        4usize,
        concat!("Alignment of ", stringify!(nk_mouse_event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mouse_event>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mouse_event),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mouse_event>())).middle as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mouse_event),
            "::",
            stringify!(middle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mouse_event>())).right as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mouse_event),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mouse_event>())).res as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mouse_event),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mouse_event>())).dx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mouse_event),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mouse_event>())).dy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mouse_event),
            "::",
            stringify!(dy)
        )
    );
}
pub type nk_mouse_event_t = nk_mouse_event;
extern "C" {
    pub fn ps2_init(naut: *mut naut_info) -> ::libc::c_int;
}
extern "C" {
    pub fn ps2_reset() -> ::libc::c_int;
}
extern "C" {
    pub fn ps2_kbd_reset() -> ::libc::c_int;
}
extern "C" {
    pub fn ps2_mouse_reset() -> ::libc::c_int;
}
extern "C" {
    pub fn ps2_deinit() -> ::libc::c_int;
}
pub const nk_vc_type_RAW: nk_vc_type = 0;
pub const nk_vc_type_COOKED: nk_vc_type = 1;
pub const nk_vc_type_RAW_NOQUEUE: nk_vc_type = 2;
pub type nk_vc_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_virtual_console {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_vc_ops {
    pub raw_noqueue: ::core::option::Option<
        unsafe extern "C" fn(arg1: nk_scancode_t, priv_: *mut ::libc::c_void),
    >,
}
#[test]
fn bindgen_test_layout_nk_vc_ops() {
    assert_eq!(
        ::core::mem::size_of::<nk_vc_ops>(),
        8usize,
        concat!("Size of: ", stringify!(nk_vc_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_vc_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_vc_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_vc_ops>())).raw_noqueue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_vc_ops),
            "::",
            stringify!(raw_noqueue)
        )
    );
}
extern "C" {
    pub fn nk_create_vc(
        name: *mut ::libc::c_char,
        new_vc_type: nk_vc_type,
        attr: u8,
        ops: *mut nk_vc_ops,
        priv_: *mut ::libc::c_void,
    ) -> *mut nk_virtual_console;
}
extern "C" {
    pub fn nk_destroy_vc(vc: *mut nk_virtual_console) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_bind_vc(thread: *mut nk_thread, cons: *mut nk_virtual_console) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_release_vc(thread: *mut nk_thread) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_get_cur_vc() -> *mut nk_virtual_console;
}
extern "C" {
    pub fn nk_switch_to_vc(vc: *mut nk_virtual_console) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_switch_to_prev_vc() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_switch_to_next_vc() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_switch_to_vc_list() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_putchar(c: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_print(s: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_puts(s: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_printf(fmt: *mut ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_log(fmt: *mut ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_printf_specific(
        vc: *mut nk_virtual_console,
        fmt: *mut ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_setattr(attr: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_setattr_specific(vc: *mut nk_virtual_console, attr: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_clear(attr: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_clear_specific(vc: *mut nk_virtual_console, attr: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_scrollup() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_scrollup_specific(vc: *mut nk_virtual_console) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_setpos(x: u8, y: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_setpos_specific(vc: *mut nk_virtual_console, x: u8, y: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_display_char(c: u8, attr: u8, x: u8, y: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_display_char_specific(
        vc: *mut nk_virtual_console,
        c: u8,
        attr: u8,
        x: u8,
        y: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_enqueue_scancode(
        vc: *mut nk_virtual_console,
        scan: nk_scancode_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_enqueue_keycode(vc: *mut nk_virtual_console, key: nk_keycode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_dequeue_scancode(vc: *mut nk_virtual_console) -> nk_scancode_t;
}
extern "C" {
    pub fn nk_vc_dequeue_keycode(vc: *mut nk_virtual_console) -> nk_keycode_t;
}
extern "C" {
    pub fn nk_vc_get_keycode(wait: ::libc::c_int) -> nk_keycode_t;
}
extern "C" {
    pub fn nk_vc_get_scancode(wait: ::libc::c_int) -> nk_scancode_t;
}
extern "C" {
    pub fn nk_vc_getchar_extended(wait: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_getchar() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_gets(
        buf: *mut ::libc::c_char,
        n: ::libc::c_int,
        display: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_handle_keyboard(scan: nk_scancode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_handle_mouse(mouse: *mut nk_mouse_event_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_init() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_is_active() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_start_chardev_console(chardev: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_vc_deinit() -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_int_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iored_entry {
    pub enabled: u8,
    pub boot_info: *mut nk_int_entry,
    pub actual_irq: u8,
}
#[test]
fn bindgen_test_layout_iored_entry() {
    assert_eq!(
        ::core::mem::size_of::<iored_entry>(),
        24usize,
        concat!("Size of: ", stringify!(iored_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<iored_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(iored_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iored_entry>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iored_entry),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iored_entry>())).boot_info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iored_entry),
            "::",
            stringify!(boot_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iored_entry>())).actual_irq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iored_entry),
            "::",
            stringify!(actual_irq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioapic {
    pub id: u8,
    pub version: u8,
    pub usable: u8,
    pub base: addr_t,
    pub num_entries: u8,
    pub entries: *mut iored_entry,
    pub first_hrt_entry: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_ioapic() {
    assert_eq!(
        ::core::mem::size_of::<ioapic>(),
        40usize,
        concat!("Size of: ", stringify!(ioapic))
    );
    assert_eq!(
        ::core::mem::align_of::<ioapic>(),
        8usize,
        concat!("Alignment of ", stringify!(ioapic))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ioapic>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ioapic),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ioapic>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ioapic),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ioapic>())).usable as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ioapic),
            "::",
            stringify!(usable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ioapic>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ioapic),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ioapic>())).num_entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ioapic),
            "::",
            stringify!(num_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ioapic>())).entries as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ioapic),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ioapic>())).first_hrt_entry as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ioapic),
            "::",
            stringify!(first_hrt_entry)
        )
    );
}
extern "C" {
    pub fn ioapic_init(sys: *mut sys_info) -> ::libc::c_int;
}
extern "C" {
    pub fn ioapic_mask_irq(ioapic: *mut ioapic, irq: u8);
}
extern "C" {
    pub fn ioapic_unmask_irq(ioapic: *mut ioapic, irq: u8);
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gdt_desc64 {
    pub limit: u16,
    pub base: u64,
}
#[test]
fn bindgen_test_layout_gdt_desc64() {
    assert_eq!(
        ::core::mem::size_of::<gdt_desc64>(),
        10usize,
        concat!("Size of: ", stringify!(gdt_desc64))
    );
    assert_eq!(
        ::core::mem::align_of::<gdt_desc64>(),
        1usize,
        concat!("Alignment of ", stringify!(gdt_desc64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc64>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc64),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc64>())).base as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc64),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gdt_desc32 {
    pub limit: u16,
    pub base: u32,
}
#[test]
fn bindgen_test_layout_gdt_desc32() {
    assert_eq!(
        ::core::mem::size_of::<gdt_desc32>(),
        6usize,
        concat!("Size of: ", stringify!(gdt_desc32))
    );
    assert_eq!(
        ::core::mem::align_of::<gdt_desc32>(),
        1usize,
        concat!("Alignment of ", stringify!(gdt_desc32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc32>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc32),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc32>())).base as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc32),
            "::",
            stringify!(base)
        )
    );
}
pub const gate_type_t_GATE_TYPE_INT: gate_type_t = 14;
pub const gate_type_t_GATE_TYPE_TRAP: gate_type_t = 15;
pub const gate_type_t_GATE_TYPE_CALL: gate_type_t = 12;
pub const gate_type_t_GATE_TYPE_TASK: gate_type_t = 5;
pub type gate_type_t = u32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct excp_entry_state {
    pub error_code: ulong_t,
    pub rip: ulong_t,
    pub cs: ulong_t,
    pub rflags: ulong_t,
    pub rsp: ulong_t,
    pub ss: ulong_t,
}
#[test]
fn bindgen_test_layout_excp_entry_state() {
    assert_eq!(
        ::core::mem::size_of::<excp_entry_state>(),
        48usize,
        concat!("Size of: ", stringify!(excp_entry_state))
    );
    assert_eq!(
        ::core::mem::align_of::<excp_entry_state>(),
        1usize,
        concat!("Alignment of ", stringify!(excp_entry_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).error_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).cs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rflags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rsp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).ss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(ss)
        )
    );
}
pub type excp_entry_t = excp_entry_state;
pub type excp_vec_t = ulong_t;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct gate_desc64 {
    pub __bindgen_anon_1: gate_desc64__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union gate_desc64__bindgen_ty_1 {
    pub __bindgen_anon_1: gate_desc64__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: gate_desc64__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gate_desc64__bindgen_ty_1__bindgen_ty_1 {
    pub val_lo: u64,
    pub val_hi: u64,
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_1>())).val_lo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val_lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_1>())).val_hi as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val_hi)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gate_desc64__bindgen_ty_1__bindgen_ty_2 {
    pub target_off_lo: u16,
    pub target_css: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub target_off_mid: u16,
    pub target_off_hi: u32,
    pub rsvd2: u32,
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_lo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_css
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_css)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_mid
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_hi
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_hi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).rsvd2 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rsvd2)
        )
    );
}
impl gate_desc64__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn ist(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ist: u8,
        rsvd0: u8,
        type_: u8,
        rsvd1: u8,
        dpl: u8,
        p: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ist: u8 = unsafe { ::core::mem::transmute(ist) };
            ist as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u8 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u8 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(gate_desc64__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_desc64__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_gate_desc64() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64>(),
        16usize,
        concat!("Size of: ", stringify!(gate_desc64))
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_desc64))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct idt_desc {
    pub size: u16,
    pub base_addr: u64,
}
#[test]
fn bindgen_test_layout_idt_desc() {
    assert_eq!(
        ::core::mem::size_of::<idt_desc>(),
        10usize,
        concat!("Size of: ", stringify!(idt_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<idt_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(idt_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idt_desc>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idt_desc>())).base_addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_desc),
            "::",
            stringify!(base_addr)
        )
    );
}
extern "C" {
    pub fn setup_idt() -> ::libc::c_int;
}
extern "C" {
    pub fn idt_assign_entry(
        entry: ulong_t,
        handler_addr: ulong_t,
        state_addr: ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn idt_get_entry(
        entry: ulong_t,
        handler_addr: *mut ulong_t,
        state_addr: *mut ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn idt_find_and_reserve_range(
        numentries: ulong_t,
        aligned: ::libc::c_int,
        first: *mut ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn null_excp_handler(
        excp: *mut excp_entry_t,
        vec: excp_vec_t,
        fault_addr: addr_t,
        state_addr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn null_irq_handler(
        excp: *mut excp_entry_t,
        vector: excp_vec_t,
        state_addr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
pub type pml4e_t = ulong_t;
pub type pdpte_t = ulong_t;
pub type pde_t = ulong_t;
pub type pte_t = ulong_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nk_pf_error {
    pub __bindgen_anon_1: nk_pf_error__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nk_pf_error__bindgen_ty_1 {
    pub val: u32,
    pub __bindgen_anon_1: nk_pf_error__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct nk_pf_error__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_nk_pf_error__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nk_pf_error__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(nk_pf_error__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nk_pf_error__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nk_pf_error__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl nk_pf_error__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn p(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_usr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd_bit(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd_bit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ifetch(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ifetch(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        p: u8,
        wr: u8,
        usr: u8,
        rsvd_bit: u8,
        ifetch: u8,
        rsvd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let p: u8 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wr: u8 = unsafe { ::core::mem::transmute(wr) };
            wr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let usr: u8 = unsafe { ::core::mem::transmute(usr) };
            usr as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rsvd_bit: u8 = unsafe { ::core::mem::transmute(rsvd_bit) };
            rsvd_bit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ifetch: u8 = unsafe { ::core::mem::transmute(ifetch) };
            ifetch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let rsvd: u32 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_nk_pf_error__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nk_pf_error__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(nk_pf_error__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_pf_error__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(nk_pf_error__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_pf_error__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_pf_error__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_nk_pf_error() {
    assert_eq!(
        ::core::mem::size_of::<nk_pf_error>(),
        4usize,
        concat!("Size of: ", stringify!(nk_pf_error))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_pf_error>(),
        1usize,
        concat!("Alignment of ", stringify!(nk_pf_error))
    );
}
pub type nk_pf_err_t = nk_pf_error;
pub const mem_zone_type_t_MEM_USABLE: mem_zone_type_t = 0;
pub const mem_zone_type_t_MEM_UNUSABLE: mem_zone_type_t = 1;
pub type mem_zone_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_mem_zone {
    pub type_: mem_zone_type_t,
    pub start: u64,
    pub length: u64,
    pub attrs: u64,
    pub node: list_head,
}
#[test]
fn bindgen_test_layout_nk_mem_zone() {
    assert_eq!(
        ::core::mem::size_of::<nk_mem_zone>(),
        48usize,
        concat!("Size of: ", stringify!(nk_mem_zone))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_mem_zone>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_mem_zone))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).attrs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).node as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(node)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_mem_info {
    pub page_map: *mut ulong_t,
    pub pm_start: addr_t,
    pub pm_end: addr_t,
    pub phys_mem_avail: ulong_t,
    pub npages: ulong_t,
    pub mem_zone_list: list_head,
}
#[test]
fn bindgen_test_layout_nk_mem_info() {
    assert_eq!(
        ::core::mem::size_of::<nk_mem_info>(),
        56usize,
        concat!("Size of: ", stringify!(nk_mem_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_mem_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_mem_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).page_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(page_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).pm_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(pm_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).pm_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(pm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).phys_mem_avail as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(phys_mem_avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).npages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).mem_zone_list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(mem_zone_list)
        )
    );
}
pub const page_size_t_PS_4K: page_size_t = 0;
pub const page_size_t_PS_2M: page_size_t = 1;
pub const page_size_t_PS_1G: page_size_t = 2;
pub type page_size_t = u32;
extern "C" {
    pub fn nk_map_page(vaddr: addr_t, paddr: addr_t, flags: u64, ps: page_size_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_map_page_nocache(paddr: addr_t, flags: u64, ps: page_size_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_paging_init(mem: *mut nk_mem_info, mbd: ulong_t);
}
extern "C" {
    pub fn nk_pf_handler(
        excp: *mut excp_entry_t,
        vector: excp_vec_t,
        fault_addr: addr_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn serial_print_redirect(format: *const ::libc::c_char, ...);
}
pub type nk_barrier_t = nk_barrier;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct nk_barrier {
    pub lock: spinlock_t,
    pub remaining: ::libc::c_uint,
    pub init_count: ::libc::c_uint,
    pub active: u8,
    pub pad: [u8; 52usize],
    pub notify: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_nk_barrier() {
    assert_eq!(
        ::core::mem::size_of::<nk_barrier>(),
        69usize,
        concat!("Size of: ", stringify!(nk_barrier))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_barrier>(),
        1usize,
        concat!("Alignment of ", stringify!(nk_barrier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).remaining as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).init_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(init_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).active as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).pad as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).notify as *const _ as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(notify)
        )
    );
}
extern "C" {
    pub fn nk_barrier_init(barrier: *mut nk_barrier_t, count: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_barrier_destroy(barrier: *mut nk_barrier_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_barrier_wait(barrier: *mut nk_barrier_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_barrier_test();
}
extern "C" {
    pub fn nk_core_barrier_raise() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_core_barrier_lower() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_core_barrier_wait() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_core_barrier_arrive() -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_counting_barrier {
    pub size: u64,
    pub count: [u64; 2usize],
    pub cur: u64,
}
#[test]
fn bindgen_test_layout_nk_counting_barrier() {
    assert_eq!(
        ::core::mem::size_of::<nk_counting_barrier>(),
        32usize,
        concat!("Size of: ", stringify!(nk_counting_barrier))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_counting_barrier>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_counting_barrier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_counting_barrier>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_counting_barrier),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_counting_barrier>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_counting_barrier),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_counting_barrier>())).cur as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_counting_barrier),
            "::",
            stringify!(cur)
        )
    );
}
pub type nk_counting_barrier_t = nk_counting_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct numa_domain {
    pub id: u32,
    pub addr_space_size: u64,
    pub num_regions: u32,
    pub regions: list_head,
    pub adj_list: list_head,
}
#[test]
fn bindgen_test_layout_numa_domain() {
    assert_eq!(
        ::core::mem::size_of::<numa_domain>(),
        56usize,
        concat!("Size of: ", stringify!(numa_domain))
    );
    assert_eq!(
        ::core::mem::align_of::<numa_domain>(),
        8usize,
        concat!("Alignment of ", stringify!(numa_domain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<numa_domain>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(numa_domain),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<numa_domain>())).addr_space_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(numa_domain),
            "::",
            stringify!(addr_space_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<numa_domain>())).num_regions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(numa_domain),
            "::",
            stringify!(num_regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<numa_domain>())).regions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(numa_domain),
            "::",
            stringify!(regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<numa_domain>())).adj_list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(numa_domain),
            "::",
            stringify!(adj_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_reg_entry {
    pub mem: *mut mem_region,
    pub mem_ent: list_head,
}
#[test]
fn bindgen_test_layout_mem_reg_entry() {
    assert_eq!(
        ::core::mem::size_of::<mem_reg_entry>(),
        24usize,
        concat!("Size of: ", stringify!(mem_reg_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_reg_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_reg_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_reg_entry>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_reg_entry),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_reg_entry>())).mem_ent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_reg_entry),
            "::",
            stringify!(mem_ent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct domain_adj_entry {
    pub domain: *mut numa_domain,
    pub list_ent: list_head,
}
#[test]
fn bindgen_test_layout_domain_adj_entry() {
    assert_eq!(
        ::core::mem::size_of::<domain_adj_entry>(),
        24usize,
        concat!("Size of: ", stringify!(domain_adj_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<domain_adj_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(domain_adj_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<domain_adj_entry>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(domain_adj_entry),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<domain_adj_entry>())).list_ent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(domain_adj_entry),
            "::",
            stringify!(list_ent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_region {
    pub domain_id: u32,
    pub base_addr: u64,
    pub len: u64,
    pub enabled: u8,
    pub hot_pluggable: u8,
    pub nonvolatile: u8,
    pub mm_state: *mut buddy_mempool,
    pub entry: list_head,
    pub glob_link: list_head,
}
#[test]
fn bindgen_test_layout_mem_region() {
    assert_eq!(
        ::core::mem::size_of::<mem_region>(),
        72usize,
        concat!("Size of: ", stringify!(mem_region))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_region>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_region))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).domain_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).base_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).enabled as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).hot_pluggable as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(hot_pluggable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).nonvolatile as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(nonvolatile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).mm_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mm_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).entry as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_region>())).glob_link as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(glob_link)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nk_locality_info {
    pub num_domains: u32,
    pub numa_matrix: *mut u8,
    pub domains: [*mut numa_domain; 128usize],
}
#[test]
fn bindgen_test_layout_nk_locality_info() {
    assert_eq!(
        ::core::mem::size_of::<nk_locality_info>(),
        1040usize,
        concat!("Size of: ", stringify!(nk_locality_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_locality_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_locality_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_locality_info>())).num_domains as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_locality_info),
            "::",
            stringify!(num_domains)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_locality_info>())).numa_matrix as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_locality_info),
            "::",
            stringify!(numa_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_locality_info>())).domains as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_locality_info),
            "::",
            stringify!(domains)
        )
    );
}
extern "C" {
    pub fn nk_cpu_topo_discover(me: *mut cpu) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_numa_init() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_dump_numa_info();
}
extern "C" {
    pub fn nk_my_numa_node() -> ::libc::c_uint;
}
extern "C" {
    pub fn nk_get_num_domains() -> ::libc::c_uint;
}
extern "C" {
    pub fn nk_numa_domain_create(sys: *mut sys_info, id: ::libc::c_uint) -> *mut numa_domain;
}
extern "C" {
    pub fn nk_get_base_region_by_cpu(cpu: cpu_id_t) -> *mut mem_region;
}
extern "C" {
    pub fn nk_get_base_region_by_num(num: ::libc::c_uint) -> *mut mem_region;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_topo_params {
    pub smt_bits: u32,
    pub core_bits: u32,
}
#[test]
fn bindgen_test_layout_nk_topo_params() {
    assert_eq!(
        ::core::mem::size_of::<nk_topo_params>(),
        8usize,
        concat!("Size of: ", stringify!(nk_topo_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_topo_params>(),
        4usize,
        concat!("Alignment of ", stringify!(nk_topo_params))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_topo_params>())).smt_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_topo_params),
            "::",
            stringify!(smt_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_topo_params>())).core_bits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_topo_params),
            "::",
            stringify!(core_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_cpu_coords {
    pub smt_id: u32,
    pub core_id: u32,
    pub pkg_id: u32,
}
#[test]
fn bindgen_test_layout_nk_cpu_coords() {
    assert_eq!(
        ::core::mem::size_of::<nk_cpu_coords>(),
        12usize,
        concat!("Size of: ", stringify!(nk_cpu_coords))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_cpu_coords>(),
        4usize,
        concat!("Alignment of ", stringify!(nk_cpu_coords))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_cpu_coords>())).smt_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_cpu_coords),
            "::",
            stringify!(smt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_cpu_coords>())).core_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_cpu_coords),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_cpu_coords>())).pkg_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_cpu_coords),
            "::",
            stringify!(pkg_id)
        )
    );
}
extern "C" {
    pub fn arch_numa_init(sys: *mut sys_info) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_mapping {
    pub ioapic: *mut ioapic,
    pub vector: u8,
    pub assigned: u8,
}
#[test]
fn bindgen_test_layout_irq_mapping() {
    assert_eq!(
        ::core::mem::size_of::<irq_mapping>(),
        16usize,
        concat!("Size of: ", stringify!(irq_mapping))
    );
    assert_eq!(
        ::core::mem::align_of::<irq_mapping>(),
        8usize,
        concat!("Alignment of ", stringify!(irq_mapping))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_mapping>())).ioapic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_mapping),
            "::",
            stringify!(ioapic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_mapping>())).vector as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_mapping),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_mapping>())).assigned as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_mapping),
            "::",
            stringify!(assigned)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nk_int_info {
    pub int_list: list_head,
    pub bus_list: list_head,
    pub irq_map: [irq_mapping; 256usize],
}
#[test]
fn bindgen_test_layout_nk_int_info() {
    assert_eq!(
        ::core::mem::size_of::<nk_int_info>(),
        4128usize,
        concat!("Size of: ", stringify!(nk_int_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_int_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_int_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_int_info>())).int_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_int_info),
            "::",
            stringify!(int_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_int_info>())).bus_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_int_info),
            "::",
            stringify!(bus_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_int_info>())).irq_map as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_int_info),
            "::",
            stringify!(irq_map)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hpet_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_link_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_prog_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sys_info {
    pub cpus: [*mut cpu; 256usize],
    pub ioapics: [*mut ioapic; 16usize],
    pub num_cpus: u32,
    pub num_ioapics: u32,
    pub flags: u64,
    pub core_barrier: *mut nk_barrier_t,
    pub mem: nk_mem_info,
    pub bsp_id: u32,
    pub pic_mode_enabled: u8,
    pub pci: *mut pci_info,
    pub hpet: *mut hpet_dev,
    pub mb_info: *mut multiboot_info,
    pub int_info: nk_int_info,
    pub locality_info: nk_locality_info,
    pub pmc_info: *mut pmc_info,
    pub linker_info: *mut nk_link_info,
    pub prog_info: *mut nk_prog_info,
}
#[test]
fn bindgen_test_layout_sys_info() {
    assert_eq!(
        ::core::mem::size_of::<sys_info>(),
        7480usize,
        concat!("Size of: ", stringify!(sys_info))
    );
    assert_eq!(
        ::core::mem::align_of::<sys_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sys_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).cpus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).ioapics as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(ioapics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).num_cpus as *const _ as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(num_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).num_ioapics as *const _ as usize },
        2180usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(num_ioapics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).flags as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).core_barrier as *const _ as usize },
        2192usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(core_barrier)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).mem as *const _ as usize },
        2200usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).bsp_id as *const _ as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(bsp_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).pic_mode_enabled as *const _ as usize },
        2260usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(pic_mode_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).pci as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(pci)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).hpet as *const _ as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(hpet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).mb_info as *const _ as usize },
        2280usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(mb_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).int_info as *const _ as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(int_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).locality_info as *const _ as usize },
        6416usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(locality_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).pmc_info as *const _ as usize },
        7456usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(pmc_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).linker_info as *const _ as usize },
        7464usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(linker_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_info>())).prog_info as *const _ as usize },
        7472usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_info),
            "::",
            stringify!(prog_info)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct naut_info {
    pub sys: sys_info,
}
#[test]
fn bindgen_test_layout_naut_info() {
    assert_eq!(
        ::core::mem::size_of::<naut_info>(),
        7480usize,
        concat!("Size of: ", stringify!(naut_info))
    );
    assert_eq!(
        ::core::mem::align_of::<naut_info>(),
        8usize,
        concat!("Alignment of ", stringify!(naut_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<naut_info>())).sys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(naut_info),
            "::",
            stringify!(sys)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}nautilus_info"]
    pub static mut nautilus_info: naut_info;
}
extern "C" {
    pub fn main();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_sched_percpu_state {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_rand_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_info {
    pub _address: u8,
}
