From ec735372648bf142e3644eb7003b6b6bdf4744cc Mon Sep 17 00:00:00 2001
From: "John Albers, Peter Dinda"
 <JohnAlbers2018@u.northwestern.edu,pdinda@northwestern.edu>
Date: Sun, 2 Sep 2018 16:42:17 -0500
Subject: [PATCH] Prototype of Rust support

Allows call of a simple Rust function from Nautilus.   See README.
---
 Kconfig                                           |   6 +
 src/Makefile                                      |   1 +
 src/nautilus/shell.c                              |  10 ++
 src/rust/Makefile                                 |  11 ++
 src/rust/README                                   | 135 ++++++++++++++++++++++
 src/rust/configs/x86_64-nautilus-core-kernel.json |  16 +++
 src/rust/example/Cargo.toml                       |  16 +++
 src/rust/example/Makefile                         |  33 ++++++
 src/rust/example/glue.c                           |  21 ++++
 src/rust/example/rust-toolchain                   |   1 +
 src/rust/example/src/lib.rs                       |  34 ++++++
 src/rust/example/x86_64-nautilus-core-kernel.json |   1 +
 src/rust/glue.c                                   |   4 +
 13 files changed, 289 insertions(+)
 create mode 100644 src/rust/Makefile
 create mode 100644 src/rust/README
 create mode 100644 src/rust/configs/x86_64-nautilus-core-kernel.json
 create mode 100644 src/rust/example/Cargo.toml
 create mode 100644 src/rust/example/Makefile
 create mode 100644 src/rust/example/glue.c
 create mode 100644 src/rust/example/rust-toolchain
 create mode 100644 src/rust/example/src/lib.rs
 create mode 120000 src/rust/example/x86_64-nautilus-core-kernel.json
 create mode 100644 src/rust/glue.c

diff --git a/Kconfig b/Kconfig
index c749086..fbb3afd 100644
--- a/Kconfig
+++ b/Kconfig
@@ -163,6 +163,12 @@ menu "Build"
         Compiles the Nautilus kernel with C++ support. Necessary for,
         e.g. C++ HRT integration
 
+    config RUST_SUPPORT
+      bool "Enable Rust support"
+      default n
+      help
+        Adds support for Rust code, and builds the Rust example and Shell command
+
     config TOOLCHAIN_ROOT
       string "Toolchain Root"
       help 
diff --git a/src/Makefile b/src/Makefile
index 481fb79..044eb37 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -13,3 +13,4 @@ obj-y += \
 obj-$(NAUT_CONFIG_CXX_SUPPORT) += cxx/
 obj-$(NAUT_CONFIG_LEGION_RT) += legion_runtime/
 obj-$(NAUT_CONFIG_LOAD_LUA) += lua_src/
+obj-$(NAUT_CONFIG_RUST_SUPPORT) += rust/
diff --git a/src/nautilus/shell.c b/src/nautilus/shell.c
index 26c5dc4..0345070 100644
--- a/src/nautilus/shell.c
+++ b/src/nautilus/shell.c
@@ -675,6 +675,16 @@ static int handle_test(char *buf)
 	return test_stop();
     }
 
+#ifdef NAUT_CONFIG_RUST_SUPPORT
+    if (!strncasecmp(what,"rust",4)) {
+	int nk_rust_example(int,int);
+	nk_vc_printf("Testing rust\n");
+	int sum = nk_rust_example(1,1);
+	nk_vc_printf("Rust indicates that 1+1=%d\n",sum);
+	return 0;
+    }
+#endif
+
 #ifdef NAUT_CONFIG_ISOCORE
     if (!strncasecmp(what,"iso",3)) { 
 	test_iso();
diff --git a/src/rust/Makefile b/src/rust/Makefile
new file mode 100644
index 0000000..e048c51
--- /dev/null
+++ b/src/rust/Makefile
@@ -0,0 +1,11 @@
+#
+# Glue code so linkage will work...
+#
+obj-y := glue.o
+
+#
+# rust modules
+#
+obj-y += example/
+
+ 
diff --git a/src/rust/README b/src/rust/README
new file mode 100644
index 0000000..38e1136
--- /dev/null
+++ b/src/rust/README
@@ -0,0 +1,135 @@
+How to use Rust code in NK, plus an example.
+
+STRUCTURE
+---------
+
+Rust code lives under src/rust.   What's immediately under that
+tree is glue code, with an example Rust module (src/rust/example).  
+
+
+SETUP
+-----
+
+DO NOT INSTALL "RELEASE" VERSIONS OF RUST.
+
+YOU NEED TO INSTALL A PER-USER COPY OF THE NIGHTLY BUILD TO HAVE THE
+RIGHT FEATURES.
+
+Yes, this fantastic evidence of stability of this tool for kernel
+development...
+
+Install rustup (http://rustup.rs), currently via:
+
+$ curl https://sh.rustup.rs -sSf | sh
+
+This will install tools in ~/.cargo/bin, which you will want to
+put on your path.
+
+$ source ~/.cargo/env
+
+You will want a file in the top level Rust module's directory called
+"rust-toolchain" whose contents should be "nightly"
+
+Also install the cargo xbuild so it can cross-compile Rust-dependent
+libraries for us:
+
+$ cargo install cargo-xbuild
+
+And we need the rust sources for it to work on:
+
+$ rustup component add rust-src
+
+
+
+CREATE A NEW RUST MODULE
+------------------------
+
+The basic idea here is that we will build a static library in Rust
+and then link that with NK.     Do this under src/rust.
+
+First create a new rust library:
+
+$ cargo new module_name --lib
+
+Now add the module subdir to src/rust/Makefile as described there.
+
+$ cd module_name
+
+Make sure that it will be built with the nightly toolchain:
+
+$ cat > rust-toolchain
+nightly
+^D
+
+Link the relevant target spec from our configs, for example:
+
+$ ln -s ../configs/x86_64-nautilus-core-kernel.json .
+
+The core-kernel config is for core kernel features.  The main thing
+here is that it does not use any floating point (including SSE for
+integer math), and that it does not use red-zone.  The run-time and
+app configs are for run-times and application code that will use
+floating point.
+
+Modify Cargo.toml in line with our examples:
+
+=> make the crate type staticlib
+=> disable unwinding
+
+modify src/lib.rs in line with our examples
+
+=> add features for panic handler, start, etc [this required NIGHTLY]
+=> provide panic handler, invoking nk_panic() if you would like
+=> assert no_std (stdlib?)
+=> possibly assert no_builtins (although it still does some...)
+
+Any functon you want to export has to look like:
+
+#[no_mangle]
+pub extern "C" fn functionaname(...) -> ... { ... }
+
+Copy glue.c and Makefile from the example module:
+
+$ cp ../example/glue.c ../example/Makefile .
+
+The glue code here (and in the top-level rust directory) force
+the damned linkage to work as you would expect despite Rust's
+static library model.
+
+Modify Makefile to reflect your module name and directory locations
+(this is currently gruesomely hacked in the KBuild process, which
+assumes that all commands run from the root of the project tree).
+
+Modify glue.c to reflect your exported symbols.  Push every exported
+function, variable, or pointer through nk_rust_link_fakery.  The types
+do not matter.  The function will never be called.  We just do not
+want the linker to lose anything, and we cannot use --whole-archive
+here because Rust itself exports unmangled conflicting symbols like
+memmove that will break the build at the parent directory. 
+
+
+CALLING INTO THE RUST MODULE
+----------------------------
+
+The only thing tested at this point is invoking a trivial Rust
+function from C. The "test rust" command from the shell will do this.
+The relevant code from shell.c shows how to do it.   In particular:
+declare the function's C prototype and call it.
+
+We do not yet know how to do:
+
+1. Nontrivial functions
+2. Rust->C callbacks
+3. Access to C structures/pointers from Rust (Swig?)
+4. Threads ?!
+5. All other things
+
+
+BUILDING
+--------
+
+Enable Rust support in make menuconfig -> Build -> Enable Rust support
+
+Build NK as usual.   Run "test rust" to see if the example works.
+
+
diff --git a/src/rust/configs/x86_64-nautilus-core-kernel.json b/src/rust/configs/x86_64-nautilus-core-kernel.json
new file mode 100644
index 0000000..3806693
--- /dev/null
+++ b/src/rust/configs/x86_64-nautilus-core-kernel.json
@@ -0,0 +1,16 @@
+{
+  "llvm-target": "x86_64-unknown-none",
+  "data-layout": "e-m:e-i64:64-f80:128-n8:16:32:64-S128",
+  "linker-flavor": "gcc",
+  "target-endian": "little",
+  "target-pointer-width": "64",
+  "target-c-int-width": "32",
+  "arch": "x86_64",
+  "os": "none",
+  "disable-redzone": true,
+  "features": "-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2,+soft-float",
+  "linker-is-gnu": true,
+  "no-compiler-rt": true,
+  "archive-format": "gnu",
+  "panic_strategy" : "abort"
+}
diff --git a/src/rust/example/Cargo.toml b/src/rust/example/Cargo.toml
new file mode 100644
index 0000000..46fbbee
--- /dev/null
+++ b/src/rust/example/Cargo.toml
@@ -0,0 +1,16 @@
+[package]
+name = "example"  # this is for core-kernel
+version = "0.0.0"
+authors = ["Peter Dinda <pdinda@northwestern.edu>"]
+
+[lib]
+crate-type = ["staticlib"]
+
+
+[profile.dev]
+panic = "abort"    # no stack unwind on rust panic
+
+[profile.release]
+panic = "abort"    # no stuck unwind on rust panic
+
+[dependencies]
diff --git a/src/rust/example/Makefile b/src/rust/example/Makefile
new file mode 100644
index 0000000..103468f
--- /dev/null
+++ b/src/rust/example/Makefile
@@ -0,0 +1,33 @@
+#
+# Rust is apparently incapable of just producing a bloody .o file,
+# so we will get it to produce a static library (a .a file) as
+# the next best thing.   Theoretically, this file is supposed to be
+# self-contained as well.
+#
+# Now, we are not invoking or using anything exported from the .a file
+# here, because our overall build process assumes we produce .os.
+# Normally this would mean the linker would just discard the .a content
+# at this point.
+
+obj-y := glue.o libexample.a 
+
+#
+# Force this step to happen all the time.  We need to use
+# Cargo to do the Rust build because, of course, you must use their
+# build environment... 
+#
+#
+.PHONY:  src/rust/example/libexample.a clean
+src/rust/example/libexample.a:
+	(cd src/rust/example &&	cargo xbuild --release --target x86_64-nautilus-core-kernel)
+	(cd src/rust/example && cp target/x86_64-nautilus-core-kernel/release/libexample.a .)
+
+#
+#
+# Does NOT work
+#
+clean:
+	(cd src/rust/example && cargo clean)
+
+
+
diff --git a/src/rust/example/glue.c b/src/rust/example/glue.c
new file mode 100644
index 0000000..acac930
--- /dev/null
+++ b/src/rust/example/glue.c
@@ -0,0 +1,21 @@
+// We need to reference exported rust functions and data here
+// so that the linker does not lose them.  Why would it lose them?
+// Because Rust insists on making a static library as the closest
+// thing to a bloody .o file.
+
+// the rust function we will call from C
+// the prototype does not matter here - this is
+// for the linker's consumption
+extern void nk_rust_example(void);
+
+// Reference to the top-level rust<->C glue.  This is
+// here just to make sure that the linker does not strip
+// out what we care about from the 
+extern volatile void *nk_rust_link_fakery;
+
+// never called, we don't care as long as there is no name collision
+void _please_mr_linker_do_not_lose_my_module_named_example()
+{
+    // we do not care about this assignment
+    nk_rust_link_fakery = (void*) nk_rust_example;
+}
diff --git a/src/rust/example/rust-toolchain b/src/rust/example/rust-toolchain
new file mode 100644
index 0000000..bf867e0
--- /dev/null
+++ b/src/rust/example/rust-toolchain
@@ -0,0 +1 @@
+nightly
diff --git a/src/rust/example/src/lib.rs b/src/rust/example/src/lib.rs
new file mode 100644
index 0000000..f1b15a7
--- /dev/null
+++ b/src/rust/example/src/lib.rs
@@ -0,0 +1,34 @@
+// give us this feature to override?
+#![feature(panic_handler, start)]
+
+// cargo cult
+#![feature(lang_items)]
+
+// no stdlib 
+#![no_std]
+
+// avoid buildins - we want it to use our library
+#![no_builtins]
+
+// nomangle + pub extern "C" means standard C linkage and visibility
+#[no_mangle]
+pub extern "C" fn nk_rust_example(a: i32, b: i32) -> i32
+{
+    return a+b;
+    //println!("Hello, world!");
+}
+
+
+
+// The following cruft is here to handle Rust->OS dependencies
+// currently only one:  Rust needs to know how to panic
+use core::panic::PanicInfo;
+
+#[panic_handler]
+#[no_mangle]
+pub fn nk_rust_panic(_info: &PanicInfo) -> !
+{
+   // should call nk_panic here...
+   loop { }
+} 
+ 
\ No newline at end of file
diff --git a/src/rust/example/x86_64-nautilus-core-kernel.json b/src/rust/example/x86_64-nautilus-core-kernel.json
new file mode 120000
index 0000000..448be53
--- /dev/null
+++ b/src/rust/example/x86_64-nautilus-core-kernel.json
@@ -0,0 +1 @@
+../configs/x86_64-nautilus-core-kernel.json
\ No newline at end of file
diff --git a/src/rust/glue.c b/src/rust/glue.c
new file mode 100644
index 0000000..51de727
--- /dev/null
+++ b/src/rust/glue.c
@@ -0,0 +1,4 @@
+// This variable is used only to rust<->c linkage issues
+// it has no actual meaning beyond that
+volatile void *nk_rust_link_fakery;
+
-- 
2.7.4

