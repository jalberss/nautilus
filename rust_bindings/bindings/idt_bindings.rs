/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__: &'static [u8; 28usize] = b"8.0.1 (branches/release_80)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Clang 8.0.1 (branches/release_80)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const NOP_1BYTE: u32 = 144;
pub const NUM_IDT_ENTRIES: u32 = 256;
pub const NUM_EXCEPTIONS: u32 = 32;
pub const DE_EXCP: u32 = 0;
pub const DB_EXCP: u32 = 1;
pub const NMI_INT: u32 = 2;
pub const BP_EXCP: u32 = 3;
pub const OF_EXCP: u32 = 4;
pub const BR_EXCP: u32 = 5;
pub const UD_EXCP: u32 = 6;
pub const NM_EXCP: u32 = 7;
pub const DF_EXCP: u32 = 8;
pub const CP_EXCP: u32 = 9;
pub const TS_EXCP: u32 = 10;
pub const NP_EXCP: u32 = 11;
pub const SS_EXCP: u32 = 12;
pub const GP_EXCP: u32 = 13;
pub const PF_EXCP: u32 = 14;
pub const MF_EXCP: u32 = 16;
pub const AC_EXCP: u32 = 17;
pub const MC_EXCP: u32 = 18;
pub const XM_EXCP: u32 = 19;
pub const VE_EXCP: u32 = 20;
pub const SE_EXCP: u32 = 30;
pub const ERR_CODE_EXCP_MASK: i32 = -4357377;
pub const KERNEL_CS: u32 = 8;
pub const KERNEL_DS: u32 = 16;
pub const KERNEL_SS: u32 = 16;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _D: u32 = 4;
pub const _C: u32 = 8;
pub const _P: u32 = 16;
pub const _S: u32 = 32;
pub const _X: u32 = 64;
pub const _SP: u32 = 128;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type schar_t = ::libc::c_schar;
pub type uchar_t = ::libc::c_uchar;
pub type sshort_t = ::libc::c_short;
pub type ushort_t = ::libc::c_ushort;
pub type sint_t = ::libc::c_int;
pub type uint_t = ::libc::c_uint;
pub type sllong_t = ::libc::c_longlong;
pub type ullong_t = ::libc::c_ulonglong;
pub type slong_t = ::libc::c_long;
pub type ulong_t = ::libc::c_ulong;
pub type off_t = ::libc::c_ulong;
pub type sint64_t = ::libc::c_long;
pub type sint32_t = ::libc::c_int;
pub type sint16_t = ::libc::c_short;
pub type sint8_t = ::libc::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gdt_desc64 {
    pub limit: u16,
    pub base: u64,
}
#[test]
fn bindgen_test_layout_gdt_desc64() {
    assert_eq!(
        ::core::mem::size_of::<gdt_desc64>(),
        10usize,
        concat!("Size of: ", stringify!(gdt_desc64))
    );
    assert_eq!(
        ::core::mem::align_of::<gdt_desc64>(),
        1usize,
        concat!("Alignment of ", stringify!(gdt_desc64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc64>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc64),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc64>())).base as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc64),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gdt_desc32 {
    pub limit: u16,
    pub base: u32,
}
#[test]
fn bindgen_test_layout_gdt_desc32() {
    assert_eq!(
        ::core::mem::size_of::<gdt_desc32>(),
        6usize,
        concat!("Size of: ", stringify!(gdt_desc32))
    );
    assert_eq!(
        ::core::mem::align_of::<gdt_desc32>(),
        1usize,
        concat!("Alignment of ", stringify!(gdt_desc32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc32>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc32),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc32>())).base as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc32),
            "::",
            stringify!(base)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ctype"]
    pub static mut _ctype: [::libc::c_uchar; 0usize];
}
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn atoi(buf: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strtoi(nptr: *const ::libc::c_char, endptr: *mut *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strtol(
        str: *const ::libc::c_char,
        endptr: *mut *mut ::libc::c_char,
        base: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn atol(nptr: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn atox(buf: *const ::libc::c_char) -> u64;
}
extern "C" {
    pub fn strtox(nptr: *const ::libc::c_char, endptr: *mut *mut ::libc::c_char) -> u64;
}
extern "C" {
    pub fn str_toupper(s: *mut ::libc::c_char);
}
extern "C" {
    pub fn str_tolower(s: *mut ::libc::c_char);
}
extern "C" {
    pub fn ultoa(
        x: ::libc::c_ulong,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ltoa(
        x: ::libc::c_long,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn utoa(
        x: ::libc::c_uint,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn itoa(
        x: ::libc::c_int,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ustoa(
        x: ::libc::c_ushort,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn stoa(
        x: ::libc::c_short,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn uctoa(
        x: ::libc::c_uchar,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ctoa(
        x: ::libc::c_char,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn dtoa_r(
        x: f64,
        mode: ::libc::c_int,
        ndigits: ::libc::c_int,
        decpt: *mut ::libc::c_int,
        sign: *mut ::libc::c_int,
        rve: *mut *mut ::libc::c_char,
        buf: *mut ::libc::c_char,
        blen: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn dtoa_printf_helper(
        x: f64,
        pf_mode: ::libc::c_char,
        ndigits: ::libc::c_int,
        prec: ::libc::c_int,
        buf: *mut ::libc::c_char,
        blen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strtod(s: *const ::libc::c_char, se: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn strtok(s: *mut ::libc::c_char, delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}
pub const gate_type_t_GATE_TYPE_INT: gate_type_t = 14;
pub const gate_type_t_GATE_TYPE_TRAP: gate_type_t = 15;
pub const gate_type_t_GATE_TYPE_CALL: gate_type_t = 12;
pub const gate_type_t_GATE_TYPE_TASK: gate_type_t = 5;
pub type gate_type_t = u32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct excp_entry_state {
    pub error_code: ulong_t,
    pub rip: ulong_t,
    pub cs: ulong_t,
    pub rflags: ulong_t,
    pub rsp: ulong_t,
    pub ss: ulong_t,
}
#[test]
fn bindgen_test_layout_excp_entry_state() {
    assert_eq!(
        ::core::mem::size_of::<excp_entry_state>(),
        48usize,
        concat!("Size of: ", stringify!(excp_entry_state))
    );
    assert_eq!(
        ::core::mem::align_of::<excp_entry_state>(),
        1usize,
        concat!("Alignment of ", stringify!(excp_entry_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).error_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).cs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rflags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rsp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).ss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(ss)
        )
    );
}
pub type excp_entry_t = excp_entry_state;
pub type excp_vec_t = ulong_t;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct gate_desc64 {
    pub __bindgen_anon_1: gate_desc64__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union gate_desc64__bindgen_ty_1 {
    pub __bindgen_anon_1: gate_desc64__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: gate_desc64__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gate_desc64__bindgen_ty_1__bindgen_ty_1 {
    pub val_lo: u64,
    pub val_hi: u64,
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_1>())).val_lo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val_lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_1>())).val_hi as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val_hi)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gate_desc64__bindgen_ty_1__bindgen_ty_2 {
    pub target_off_lo: u16,
    pub target_css: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub target_off_mid: u16,
    pub target_off_hi: u32,
    pub rsvd2: u32,
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_lo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_css
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_css)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_mid
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_hi
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_hi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).rsvd2 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rsvd2)
        )
    );
}
impl gate_desc64__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn ist(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ist: u8,
        rsvd0: u8,
        type_: u8,
        rsvd1: u8,
        dpl: u8,
        p: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ist: u8 = unsafe { ::core::mem::transmute(ist) };
            ist as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u8 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u8 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(gate_desc64__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_desc64__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_gate_desc64() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64>(),
        16usize,
        concat!("Size of: ", stringify!(gate_desc64))
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_desc64))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct idt_desc {
    pub size: u16,
    pub base_addr: u64,
}
#[test]
fn bindgen_test_layout_idt_desc() {
    assert_eq!(
        ::core::mem::size_of::<idt_desc>(),
        10usize,
        concat!("Size of: ", stringify!(idt_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<idt_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(idt_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idt_desc>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idt_desc>())).base_addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_desc),
            "::",
            stringify!(base_addr)
        )
    );
}
extern "C" {
    pub fn setup_idt() -> ::libc::c_int;
}
extern "C" {
    pub fn idt_assign_entry(
        entry: ulong_t,
        handler_addr: ulong_t,
        state_addr: ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn idt_get_entry(
        entry: ulong_t,
        handler_addr: *mut ulong_t,
        state_addr: *mut ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn idt_find_and_reserve_range(
        numentries: ulong_t,
        aligned: ::libc::c_int,
        first: *mut ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn null_excp_handler(
        excp: *mut excp_entry_t,
        vec: excp_vec_t,
        fault_addr: addr_t,
        state_addr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn null_irq_handler(
        excp: *mut excp_entry_t,
        vector: excp_vec_t,
        state_addr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
