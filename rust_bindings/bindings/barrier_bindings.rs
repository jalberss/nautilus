/* automatically generated by rust-bindgen */

pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__: &'static [u8; 28usize] = b"8.0.1 (branches/release_80)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Clang 8.0.1 (branches/release_80)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const RFLAGS_CF: u32 = 1;
pub const RFLAGS_PF: u32 = 4;
pub const RFLAGS_AF: u32 = 16;
pub const RFLAGS_ZF: u32 = 64;
pub const RFLAGS_SF: u32 = 128;
pub const RFLAGS_TF: u32 = 256;
pub const RFLAGS_IF: u32 = 512;
pub const RFLAGS_DF: u32 = 1024;
pub const RFLAGS_OF: u32 = 2048;
pub const RFLAGS_IOPL: u32 = 12288;
pub const RFLAGS_VM: u32 = 143360;
pub const RFLAGS_VIF: u32 = 524288;
pub const RFLAGS_VIP: u32 = 1048576;
pub const CR0_PE: u32 = 1;
pub const CR0_MP: u32 = 2;
pub const CR0_EM: u32 = 4;
pub const CR0_TS: u32 = 8;
pub const CR0_NE: u32 = 32;
pub const CR0_WP: u32 = 65536;
pub const CR0_AM: u32 = 262144;
pub const CR0_NW: u32 = 536870912;
pub const CR0_CD: u32 = 1073741824;
pub const CR0_PG: u32 = 2147483648;
pub const CR4_VME: u32 = 1;
pub const CR4_PVI: u32 = 2;
pub const CR4_TSD: u32 = 4;
pub const CR4_DE: u32 = 8;
pub const CR4_PSE: u32 = 16;
pub const CR4_PAE: u32 = 32;
pub const CR4_MCE: u32 = 64;
pub const CR4_PGE: u32 = 128;
pub const CR4_PCE: u32 = 256;
pub const CR4_OSFXSR: u32 = 512;
pub const CR4_OSXMMEXCPT: u32 = 1024;
pub const CR4_VMXE: u32 = 8192;
pub const CR4_XMXE: u32 = 16384;
pub const CR4_FSGSBASE: u32 = 65536;
pub const CR4_PCIDE: u32 = 131072;
pub const CR4_OSXSAVE: u32 = 262144;
pub const CR4_SMEP: u32 = 1048576;
pub const IA32_TIME_STAMP_COUNTER: u32 = 16;
pub const IA32_MSR_EFER: u32 = 3221225600;
pub const IA32_MSR_APIC_BASE: u32 = 27;
pub const IA32_MISC_ENABLES: u32 = 416;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NXE: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const EFER_TCE: u32 = 32768;
pub const AMD_MSR_TSC: u32 = 16;
pub const AMD_MSR_APIC_BASE: u32 = 27;
pub const AMD_MSR_MPERF: u32 = 231;
pub const AMD_MSR_APERF: u32 = 232;
pub const AMD_MSR_MTRRCAP: u32 = 254;
pub const AMD_MSR_SYSENTER_CS: u32 = 372;
pub const AMD_MSR_SYSENTER_ESP: u32 = 373;
pub const AMD_MSR_SYSENTER_EIP: u32 = 374;
pub const AMD_MSR_MCG_CAP: u32 = 377;
pub const AMD_MSR_MCG_STATUS: u32 = 378;
pub const AMD_MSR_MCG_CTL: u32 = 379;
pub const AMD_MSR_DEBUG_CTL: u32 = 473;
pub const AMD_MSR_PAT: u32 = 631;
pub const AMD_MSR_STAR: u32 = 3221225601;
pub const AMD_MSR_LSTAR: u32 = 3221225602;
pub const AMD_MSR_CSTAR: u32 = 3221225603;
pub const AMD_MSR_SFMASK: u32 = 3221225604;
pub const AMD_MSR_FSBASE: u32 = 3221225728;
pub const AMD_MSR_GSBASE: u32 = 3221225729;
pub const AMD_MSR_KERN_GSBASE: u32 = 3221225730;
pub const AMD_MSR_TSC_AUX: u32 = 3221225731;
pub const AMD_MSR_SYSCFG: u32 = 3221291024;
pub const AMD_MSR_VM_CR: u32 = 3221291284;
pub const AMD_MSR_NBRIDGE_CTL: u32 = 3221291039;
pub const INSTR_CAL_LOOPS: u32 = 1000;
pub const SPINLOCK_INITIALIZER: u32 = 0;
pub const NK_BARRIER_LAST: u32 = 1;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type schar_t = ::libc::c_schar;
pub type uchar_t = ::libc::c_uchar;
pub type sshort_t = ::libc::c_short;
pub type ushort_t = ::libc::c_ushort;
pub type sint_t = ::libc::c_int;
pub type uint_t = ::libc::c_uint;
pub type sllong_t = ::libc::c_longlong;
pub type ullong_t = ::libc::c_ulonglong;
pub type slong_t = ::libc::c_long;
pub type ulong_t = ::libc::c_ulong;
pub type off_t = ::libc::c_ulong;
pub type sint64_t = ::libc::c_long;
pub type sint32_t = ::libc::c_int;
pub type sint16_t = ::libc::c_short;
pub type sint8_t = ::libc::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
extern "C" {
    pub fn nk_detect_cpu_freq(arg1: u32) -> ulong_t;
}
extern "C" {
    pub fn nk_is_amd() -> u8;
}
extern "C" {
    pub fn nk_is_intel() -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_regs {
    pub r15: ulong_t,
    pub r14: ulong_t,
    pub r13: ulong_t,
    pub r12: ulong_t,
    pub r11: ulong_t,
    pub r10: ulong_t,
    pub r9: ulong_t,
    pub r8: ulong_t,
    pub rbp: ulong_t,
    pub rdi: ulong_t,
    pub rsi: ulong_t,
    pub rdx: ulong_t,
    pub rcx: ulong_t,
    pub rbx: ulong_t,
    pub rax: ulong_t,
    pub vector: ulong_t,
    pub err_code: ulong_t,
    pub rip: ulong_t,
    pub cs: ulong_t,
    pub rflags: ulong_t,
    pub rsp: ulong_t,
    pub ss: ulong_t,
}
#[test]
fn bindgen_test_layout_nk_regs() {
    assert_eq!(
        ::core::mem::size_of::<nk_regs>(),
        176usize,
        concat!("Size of: ", stringify!(nk_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_regs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r11 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r10 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r9 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r8 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rbp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rdi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rsi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rdx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rcx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rbx as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rax as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).vector as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).err_code as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rip as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rflags as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rsp as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).ss as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(ss)
        )
    );
}
extern "C" {
    pub fn msr_write(msr: u32, data: u64);
}
extern "C" {
    pub fn msr_read(msr: u32) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_hashtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_malloc_data() {
    assert_eq!(
        ::core::mem::size_of::<malloc_data>(),
        40usize,
        concat!("Size of: ", stringify!(malloc_data))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_data>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_free_data() {
    assert_eq!(
        ::core::mem::size_of::<free_data>(),
        40usize,
        concat!("Size of: ", stringify!(free_data))
    );
    assert_eq!(
        ::core::mem::align_of::<free_data>(),
        8usize,
        concat!("Alignment of ", stringify!(free_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_irq_data() {
    assert_eq!(
        ::core::mem::size_of::<irq_data>(),
        40usize,
        concat!("Size of: ", stringify!(irq_data))
    );
    assert_eq!(
        ::core::mem::align_of::<irq_data>(),
        8usize,
        concat!("Alignment of ", stringify!(irq_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_switch_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_thread_switch_data() {
    assert_eq!(
        ::core::mem::size_of::<thread_switch_data>(),
        40usize,
        concat!("Size of: ", stringify!(thread_switch_data))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_switch_data>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_switch_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_instr_data {
    pub func_htable: *mut nk_hashtable,
    pub irqstat: irq_data,
    pub mallocstat: malloc_data,
    pub freestat: free_data,
    pub thr_switch: thread_switch_data,
}
#[test]
fn bindgen_test_layout_nk_instr_data() {
    assert_eq!(
        ::core::mem::size_of::<nk_instr_data>(),
        168usize,
        concat!("Size of: ", stringify!(nk_instr_data))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_instr_data>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_instr_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).func_htable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(func_htable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).irqstat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(irqstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).mallocstat as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(mallocstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).freestat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(freestat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).thr_switch as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(thr_switch)
        )
    );
}
extern "C" {
    pub fn nk_profile_func_enter(func: *const ::libc::c_char);
}
extern "C" {
    pub fn nk_profile_func_exit(func: *const ::libc::c_char);
}
extern "C" {
    pub fn nk_thr_switch_prof_enter();
}
extern "C" {
    pub fn nk_thr_switch_prof_exit();
}
extern "C" {
    pub fn nk_irq_prof_enter();
}
extern "C" {
    pub fn nk_irq_prof_exit();
}
extern "C" {
    pub fn nk_malloc_enter();
}
extern "C" {
    pub fn nk_malloc_exit();
}
extern "C" {
    pub fn nk_free_enter();
}
extern "C" {
    pub fn nk_free_exit();
}
extern "C" {
    pub fn nk_instrument_init();
}
extern "C" {
    pub fn nk_instrument_start();
}
extern "C" {
    pub fn nk_instrument_end();
}
extern "C" {
    pub fn nk_instrument_query();
}
extern "C" {
    pub fn nk_instrument_clear();
}
extern "C" {
    pub fn nk_instrument_calibrate(loops: ::libc::c_uint);
}
pub type spinlock_t = u32;
extern "C" {
    pub fn spinlock_init(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spinlock_deinit(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_nopause(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_irq_save_nopause(lock: *mut spinlock_t) -> u8;
}
pub type nk_barrier_t = nk_barrier;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct nk_barrier {
    pub lock: spinlock_t,
    pub remaining: ::libc::c_uint,
    pub init_count: ::libc::c_uint,
    pub active: u8,
    pub pad: [u8; 52usize],
    pub notify: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_nk_barrier() {
    assert_eq!(
        ::core::mem::size_of::<nk_barrier>(),
        69usize,
        concat!("Size of: ", stringify!(nk_barrier))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_barrier>(),
        1usize,
        concat!("Alignment of ", stringify!(nk_barrier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).remaining as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).init_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(init_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).active as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).pad as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_barrier>())).notify as *const _ as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_barrier),
            "::",
            stringify!(notify)
        )
    );
}
extern "C" {
    pub fn nk_barrier_init(barrier: *mut nk_barrier_t, count: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_barrier_destroy(barrier: *mut nk_barrier_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_barrier_wait(barrier: *mut nk_barrier_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_barrier_test();
}
extern "C" {
    pub fn nk_core_barrier_raise() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_core_barrier_lower() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_core_barrier_wait() -> ::libc::c_int;
}
extern "C" {
    pub fn nk_core_barrier_arrive() -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_counting_barrier {
    pub size: u64,
    pub count: [u64; 2usize],
    pub cur: u64,
}
#[test]
fn bindgen_test_layout_nk_counting_barrier() {
    assert_eq!(
        ::core::mem::size_of::<nk_counting_barrier>(),
        32usize,
        concat!("Size of: ", stringify!(nk_counting_barrier))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_counting_barrier>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_counting_barrier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_counting_barrier>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_counting_barrier),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_counting_barrier>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_counting_barrier),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_counting_barrier>())).cur as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_counting_barrier),
            "::",
            stringify!(cur)
        )
    );
}
pub type nk_counting_barrier_t = nk_counting_barrier;
