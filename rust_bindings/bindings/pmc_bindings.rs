/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__: &'static [u8; 28usize] = b"8.0.1 (branches/release_80)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Clang 8.0.1 (branches/release_80)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const AMD_PMC_LEAF: u32 = 2147483649;
pub const AMD_PERF_SLOTS: u32 = 6;
pub const AMD_PERF_CTL0_MSR: u32 = 3221291520;
pub const AMD_PERF_CTL1_MSR: u32 = 3221291522;
pub const AMD_PERF_CTL2_MSR: u32 = 3221291524;
pub const AMD_PERF_CTL3_MSR: u32 = 3221291526;
pub const AMD_PERF_CTL4_MSR: u32 = 3221291528;
pub const AMD_PERF_CTL5_MSR: u32 = 3221291530;
pub const AMD_PERF_CTR0_MSR: u32 = 3221291521;
pub const AMD_PERF_CTR1_MSR: u32 = 3221291523;
pub const AMD_PERF_CTR2_MSR: u32 = 3221291525;
pub const AMD_PERF_CTR3_MSR: u32 = 3221291527;
pub const AMD_PERF_CTR4_MSR: u32 = 3221291529;
pub const AMD_PERF_CTR5_MSR: u32 = 3221291531;
pub const IA32_PMC_LEAF: u32 = 10;
pub const IA32_PMC_BASE: u32 = 193;
pub const IA32_PERFEVTSEL_BASE: u32 = 390;
pub const INTEL_UNHALTED_CORE_CYCLES: u32 = 0;
pub const INTEL_INSTR_RETIRED: u32 = 1;
pub const INTEL_UNHALTED_REF_CYCLES: u32 = 2;
pub const INTEL_LLC_REF: u32 = 3;
pub const INTEL_LLC_MISS: u32 = 4;
pub const INTEL_BRANCH_RETIRED: u32 = 5;
pub const INTEL_BRANCH_MISS_RETIRED: u32 = 6;
pub const INTEL_NUM_ARCH_EVENTS: u32 = 7;
pub const INTEL_DTLB_LOAD_MISS_WALK: u32 = 7;
pub const AMD_DATA_CACHE_MISS: u32 = 0;
pub const AMD_INSTR_CACHE_MISS: u32 = 1;
pub const AMD_L2_CACHE_MISS: u32 = 2;
pub const AMD_UNIFIED_TLB_MISS: u32 = 3;
pub const AMD_SMI_INT: u32 = 4;
pub const AMD_INSTR_FETCH_STALLS: u32 = 5;
pub const AMD_BRANCH_MISS_RETIRED: u32 = 6;
pub const AMD_INSTR_CACHE_INVALS: u32 = 7;
pub const AMD_EXT_CNT_FLAG: u32 = 1;
pub const AMD_NB_CNT_FLAG: u32 = 2;
pub const AMD_L3_CNT_FLAG: u32 = 4;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type schar_t = ::libc::c_schar;
pub type uchar_t = ::libc::c_uchar;
pub type sshort_t = ::libc::c_short;
pub type ushort_t = ::libc::c_ushort;
pub type sint_t = ::libc::c_int;
pub type uint_t = ::libc::c_uint;
pub type sllong_t = ::libc::c_longlong;
pub type ullong_t = ::libc::c_ulonglong;
pub type slong_t = ::libc::c_long;
pub type ulong_t = ::libc::c_ulong;
pub type off_t = ::libc::c_ulong;
pub type sint64_t = ::libc::c_long;
pub type sint32_t = ::libc::c_int;
pub type sint16_t = ::libc::c_short;
pub type sint8_t = ::libc::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amd_event_attr {
    pub name: *const ::libc::c_char,
    pub id: u8,
    pub umask: u8,
    pub slot_mask: u8,
}
#[test]
fn bindgen_test_layout_amd_event_attr() {
    assert_eq!(
        ::core::mem::size_of::<amd_event_attr>(),
        16usize,
        concat!("Size of: ", stringify!(amd_event_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<amd_event_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(amd_event_attr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<amd_event_attr>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(amd_event_attr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<amd_event_attr>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(amd_event_attr),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<amd_event_attr>())).umask as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(amd_event_attr),
            "::",
            stringify!(umask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<amd_event_attr>())).slot_mask as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(amd_event_attr),
            "::",
            stringify!(slot_mask)
        )
    );
}
pub type amd_event_attr_t = amd_event_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intel_event_attr {
    pub name: *const ::libc::c_char,
    pub id: u8,
    pub umask: u8,
    pub bit_pos: u8,
}
#[test]
fn bindgen_test_layout_intel_event_attr() {
    assert_eq!(
        ::core::mem::size_of::<intel_event_attr>(),
        16usize,
        concat!("Size of: ", stringify!(intel_event_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<intel_event_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(intel_event_attr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<intel_event_attr>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(intel_event_attr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<intel_event_attr>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(intel_event_attr),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<intel_event_attr>())).umask as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(intel_event_attr),
            "::",
            stringify!(umask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<intel_event_attr>())).bit_pos as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(intel_event_attr),
            "::",
            stringify!(bit_pos)
        )
    );
}
pub type intel_event_attr_t = intel_event_attr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event_platform_attrs {
    pub __bindgen_anon_1: event_platform_attrs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event_platform_attrs__bindgen_ty_1 {
    pub intel_attrs: *mut intel_event_attr,
    pub amd_attrs: *mut amd_event_attr,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_event_platform_attrs__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<event_platform_attrs__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(event_platform_attrs__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<event_platform_attrs__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event_platform_attrs__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<event_platform_attrs__bindgen_ty_1>())).intel_attrs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_platform_attrs__bindgen_ty_1),
            "::",
            stringify!(intel_attrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<event_platform_attrs__bindgen_ty_1>())).amd_attrs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_platform_attrs__bindgen_ty_1),
            "::",
            stringify!(amd_attrs)
        )
    );
}
#[test]
fn bindgen_test_layout_event_platform_attrs() {
    assert_eq!(
        ::core::mem::size_of::<event_platform_attrs>(),
        8usize,
        concat!("Size of: ", stringify!(event_platform_attrs))
    );
    assert_eq!(
        ::core::mem::align_of::<event_platform_attrs>(),
        8usize,
        concat!("Alignment of ", stringify!(event_platform_attrs))
    );
}
pub type event_platform_attrs_t = event_platform_attrs;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmc_event {
    pub assigned_idx: u8,
    pub enabled: u8,
    pub bound: u8,
    pub sw_id: u32,
    pub val: u64,
    pub name: *const ::libc::c_char,
    pub attrs: event_platform_attrs_t,
}
#[test]
fn bindgen_test_layout_pmc_event() {
    assert_eq!(
        ::core::mem::size_of::<pmc_event>(),
        32usize,
        concat!("Size of: ", stringify!(pmc_event))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_event>(),
        8usize,
        concat!("Alignment of ", stringify!(pmc_event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_event>())).assigned_idx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_event),
            "::",
            stringify!(assigned_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_event>())).enabled as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_event),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_event>())).bound as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_event),
            "::",
            stringify!(bound)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_event>())).sw_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_event),
            "::",
            stringify!(sw_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_event>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_event),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_event>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_event),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_event>())).attrs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_event),
            "::",
            stringify!(attrs)
        )
    );
}
pub type perf_event_t = pmc_event;
pub const slot_status_t_PMC_SLOT_FREE: slot_status_t = 0;
pub const slot_status_t_PMC_SLOT_USED: slot_status_t = 1;
pub type slot_status_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_slot {
    pub status: slot_status_t,
    pub event: *mut perf_event_t,
}
#[test]
fn bindgen_test_layout_perf_slot() {
    assert_eq!(
        ::core::mem::size_of::<perf_slot>(),
        16usize,
        concat!("Size of: ", stringify!(perf_slot))
    );
    assert_eq!(
        ::core::mem::align_of::<perf_slot>(),
        8usize,
        concat!("Alignment of ", stringify!(perf_slot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<perf_slot>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_slot),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<perf_slot>())).event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(perf_slot),
            "::",
            stringify!(event)
        )
    );
}
pub type perf_slot_t = perf_slot;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pmc_ctl_intel {
    pub __bindgen_anon_1: pmc_ctl_intel__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union pmc_ctl_intel__bindgen_ty_1 {
    pub val: u64,
    pub __bindgen_anon_1: pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1 {
    pub event_select: u8,
    pub unit_mask: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub cmask: u8,
    pub rsvd1: u32,
}
#[test]
fn bindgen_test_layout_pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1>())).event_select
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(event_select)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1>())).unit_mask
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(unit_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1>())).cmask as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1>())).rsvd1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsvd1)
        )
    );
}
impl pmc_ctl_intel__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn usr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_usr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn os(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_os(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn any(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_any(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr: u8,
        os: u8,
        e: u8,
        pc: u8,
        intr: u8,
        any: u8,
        en: u8,
        inv: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let usr: u8 = unsafe { ::core::mem::transmute(usr) };
            usr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let os: u8 = unsafe { ::core::mem::transmute(os) };
            os as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let e: u8 = unsafe { ::core::mem::transmute(e) };
            e as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pc: u8 = unsafe { ::core::mem::transmute(pc) };
            pc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let intr: u8 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let any: u8 = unsafe { ::core::mem::transmute(any) };
            any as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let en: u8 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inv: u8 = unsafe { ::core::mem::transmute(inv) };
            inv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_pmc_ctl_intel__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pmc_ctl_intel__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pmc_ctl_intel__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_ctl_intel__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(pmc_ctl_intel__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pmc_ctl_intel__bindgen_ty_1>())).val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ctl_intel__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_pmc_ctl_intel() {
    assert_eq!(
        ::core::mem::size_of::<pmc_ctl_intel>(),
        8usize,
        concat!("Size of: ", stringify!(pmc_ctl_intel))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_ctl_intel>(),
        1usize,
        concat!("Alignment of ", stringify!(pmc_ctl_intel))
    );
}
pub type pmc_ctl_intel_t = pmc_ctl_intel;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pmc_ctl_amd {
    pub __bindgen_anon_1: pmc_ctl_amd__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union pmc_ctl_amd__bindgen_ty_1 {
    pub val: u64,
    pub __bindgen_anon_1: pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout_pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl pmc_ctl_amd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn event_select0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_event_select0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn unit_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_unit_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn usr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_usr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn os(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_os(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_edge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_cnt_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn event_select1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_event_select1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hg_only(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_hg_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        event_select0: u8,
        unit_mask: u8,
        usr: u8,
        os: u8,
        edge: u8,
        rsvd0: u8,
        int_enable: u8,
        rsvd1: u8,
        en: u8,
        inv: u8,
        cnt_mask: u8,
        event_select1: u8,
        rsvd2: u8,
        hg_only: u8,
        rsvd3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let event_select0: u8 = unsafe { ::core::mem::transmute(event_select0) };
            event_select0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let unit_mask: u8 = unsafe { ::core::mem::transmute(unit_mask) };
            unit_mask as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let usr: u8 = unsafe { ::core::mem::transmute(usr) };
            usr as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let os: u8 = unsafe { ::core::mem::transmute(os) };
            os as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let edge: u8 = unsafe { ::core::mem::transmute(edge) };
            edge as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let int_enable: u8 = unsafe { ::core::mem::transmute(int_enable) };
            int_enable as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let en: u8 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let inv: u8 = unsafe { ::core::mem::transmute(inv) };
            inv as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let cnt_mask: u8 = unsafe { ::core::mem::transmute(cnt_mask) };
            cnt_mask as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let event_select1: u8 = unsafe { ::core::mem::transmute(event_select1) };
            event_select1 as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let rsvd2: u8 = unsafe { ::core::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(40usize, 2u8, {
            let hg_only: u8 = unsafe { ::core::mem::transmute(hg_only) };
            hg_only as u64
        });
        __bindgen_bitfield_unit.set(42usize, 22u8, {
            let rsvd3: u32 = unsafe { ::core::mem::transmute(rsvd3) };
            rsvd3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_pmc_ctl_amd__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pmc_ctl_amd__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pmc_ctl_amd__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_ctl_amd__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(pmc_ctl_amd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ctl_amd__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ctl_amd__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_pmc_ctl_amd() {
    assert_eq!(
        ::core::mem::size_of::<pmc_ctl_amd>(),
        8usize,
        concat!("Size of: ", stringify!(pmc_ctl_amd))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_ctl_amd>(),
        1usize,
        concat!("Alignment of ", stringify!(pmc_ctl_amd))
    );
}
pub type pmc_ctl_amd_t = pmc_ctl_amd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_ops {
    pub read_ctr: ::core::option::Option<unsafe extern "C" fn(idx: u8) -> u64>,
    pub write_ctr: ::core::option::Option<unsafe extern "C" fn(idx: u8, val: u64)>,
    pub enable_ctr: ::core::option::Option<unsafe extern "C" fn(event: *mut perf_event_t)>,
    pub disable_ctr: ::core::option::Option<unsafe extern "C" fn(event: *mut perf_event_t)>,
    pub bind_ctr: ::core::option::Option<
        unsafe extern "C" fn(event: *mut perf_event_t, slot: ::libc::c_int) -> ::libc::c_int,
    >,
    pub unbind_ctr: ::core::option::Option<unsafe extern "C" fn(slot: ::libc::c_int)>,
    pub init: ::core::option::Option<unsafe extern "C" fn(pmc: *mut pmc_info) -> ::libc::c_int>,
    pub event_init: ::core::option::Option<unsafe extern "C" fn(event: *mut perf_event_t)>,
    pub version: ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>,
    pub msr_cnt: ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>,
    pub msr_width: ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>,
}
#[test]
fn bindgen_test_layout_pmc_ops() {
    assert_eq!(
        ::core::mem::size_of::<pmc_ops>(),
        88usize,
        concat!("Size of: ", stringify!(pmc_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pmc_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).read_ctr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(read_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).write_ctr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(write_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).enable_ctr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(enable_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).disable_ctr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(disable_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).bind_ctr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(bind_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).unbind_ctr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(unbind_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).init as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).event_init as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(event_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).version as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).msr_cnt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(msr_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_ops>())).msr_width as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_ops),
            "::",
            stringify!(msr_width)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmc_info {
    pub valid: ::libc::c_int,
    pub hw_num_slots: ::libc::c_int,
    pub sw_num_slots: ::libc::c_int,
    pub slots: *mut perf_slot_t,
    pub version_id: u8,
    pub msr_cnt: u8,
    pub msr_width: u8,
    pub ops: *mut pmc_ops,
    pub __bindgen_anon_1: pmc_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmc_info__bindgen_ty_1 {
    pub intel_fl: u32,
    pub amd_fl: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pmc_info__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pmc_info__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(pmc_info__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pmc_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pmc_info__bindgen_ty_1>())).intel_fl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info__bindgen_ty_1),
            "::",
            stringify!(intel_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info__bindgen_ty_1>())).amd_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info__bindgen_ty_1),
            "::",
            stringify!(amd_fl)
        )
    );
}
#[test]
fn bindgen_test_layout_pmc_info() {
    assert_eq!(
        ::core::mem::size_of::<pmc_info>(),
        48usize,
        concat!("Size of: ", stringify!(pmc_info))
    );
    assert_eq!(
        ::core::mem::align_of::<pmc_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pmc_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).hw_num_slots as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(hw_num_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).sw_num_slots as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(sw_num_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).slots as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).version_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(version_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).msr_cnt as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(msr_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).msr_width as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(msr_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmc_info>())).ops as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pmc_info),
            "::",
            stringify!(ops)
        )
    );
}
pub type pmc_info_t = pmc_info;
extern "C" {
    pub fn nk_pmc_init(naut: *mut naut_info) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_pmc_create(event_id: u32) -> *mut perf_event_t;
}
extern "C" {
    pub fn nk_pmc_destroy(event: *mut perf_event_t);
}
extern "C" {
    pub fn nk_pmc_start(event: *mut perf_event_t);
}
extern "C" {
    pub fn nk_pmc_stop(event: *mut perf_event_t);
}
extern "C" {
    pub fn nk_pmc_read(event: *mut perf_event_t) -> u64;
}
extern "C" {
    pub fn nk_pmc_write(event: *mut perf_event_t, val: u64);
}
extern "C" {
    pub fn nk_pmc_report();
}
extern "C" {
    pub fn test_pmc(pmc_id: ::libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct naut_info {
    pub _address: u8,
}
