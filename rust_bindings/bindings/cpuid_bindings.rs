/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__: &'static [u8; 28usize] = b"8.0.1 (branches/release_80)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Clang 8.0.1 (branches/release_80)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const CPUID_BASIC_INFO: u32 = 0;
pub const CPUID_FEATURE_INFO: u32 = 1;
pub const CPUID_AMD_BASIC_INFO: u32 = 2147483648;
pub const CPUID_AMD_FEATURE_INFO: u32 = 2147483649;
pub const CPUID_AMD_EXT_INFO: u32 = 2147483656;
pub const CPUID_LEAF_BASIC_INFO0: u32 = 0;
pub const CPUID_LEAF_BASIC_INFO1: u32 = 1;
pub const CPUID_LEAF_BASIC_INFO2: u32 = 2;
pub const CPUID_LEAF_BASIC_INFO3: u32 = 3;
pub const CPUID_LEAF_CACHE_PARM: u32 = 4;
pub const CPUID_LEAF_MWAIT: u32 = 5;
pub const CPUID_LEAF_THERMAL: u32 = 6;
pub const CPUID_LEAF_EXT_FEATS: u32 = 7;
pub const CPUID_LEAF_CACHE_ACCESS: u32 = 9;
pub const CPUID_LEAF_PERF_MON: u32 = 10;
pub const CPUID_LEAF_TOP_ENUM: u32 = 11;
pub const CPUID_LEAF_EXT_STATE: u32 = 13;
pub const CPUID_LEAF_QOS_MON: u32 = 15;
pub const CPUID_LEAF_QOS_ENF: u32 = 16;
pub const CPUID_EXT_FUNC_MAXVAL: u32 = 2147483648;
pub const CPUID_EXT_FUNC_SIG_FEAT: u32 = 2147483649;
pub const CPUID_EXT_FUNC_BRND_STR0: u32 = 2147483650;
pub const CPUID_EXT_FUNC_BRND_STR1: u32 = 2147483651;
pub const CPUID_EXT_FUNC_BRND_STR2: u32 = 2147483652;
pub const CPUID_EXT_FUNC_RSVD: u32 = 2147483653;
pub const CPUID_EXT_FUNC_CACHE1: u32 = 2147483654;
pub const CPUID_EXT_FUNC_INV_TSC: u32 = 2147483655;
pub const CPUID_EXT_FUNC_ADDR_SZ: u32 = 2147483656;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type schar_t = ::libc::c_schar;
pub type uchar_t = ::libc::c_uchar;
pub type sshort_t = ::libc::c_short;
pub type ushort_t = ::libc::c_ushort;
pub type sint_t = ::libc::c_int;
pub type uint_t = ::libc::c_uint;
pub type sllong_t = ::libc::c_longlong;
pub type ullong_t = ::libc::c_ulonglong;
pub type slong_t = ::libc::c_long;
pub type ulong_t = ::libc::c_ulong;
pub type off_t = ::libc::c_ulong;
pub type sint64_t = ::libc::c_long;
pub type sint32_t = ::libc::c_int;
pub type sint16_t = ::libc::c_short;
pub type sint8_t = ::libc::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
extern "C" {
    pub fn cpuid_leaf_max() -> u32;
}
extern "C" {
    pub fn cpuid_get_family() -> u8;
}
extern "C" {
    pub fn cpuid_get_model() -> u8;
}
extern "C" {
    pub fn cpuid_get_step() -> u8;
}
extern "C" {
    pub fn detect_cpu();
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct cpuid_ecx_flags {
    pub __bindgen_anon_1: cpuid_ecx_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union cpuid_ecx_flags__bindgen_ty_1 {
    pub val: u32,
    pub __bindgen_anon_1: cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl cpuid_ecx_flags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sse3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sse3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pclmuldq(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pclmuldq(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dtest64(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dtest64(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn monitor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_monitor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ds_cpl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ds_cpl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vmx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vmx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_smx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eist(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_eist(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tm2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tm2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssse3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ssse3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnxt_id(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnxt_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdbg(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sdbg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fma(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fma(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cx16(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cx16(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtpr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xtpr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdcm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pdcm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dca(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dca(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4dot1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sse4dot1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4dot2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sse4dot2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x2apic(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_x2apic(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn movbe(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_movbe(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn popcnt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_popcnt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc_dline(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tsc_dline(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aesni(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_aesni(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xsave(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xsave(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn osxsave(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_osxsave(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_avx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn f16c(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_f16c(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdrand(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rdrand(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn notused(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_notused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sse3: u8,
        pclmuldq: u8,
        dtest64: u8,
        monitor: u8,
        ds_cpl: u8,
        vmx: u8,
        smx: u8,
        eist: u8,
        tm2: u8,
        ssse3: u8,
        cnxt_id: u8,
        sdbg: u8,
        fma: u8,
        cx16: u8,
        xtpr: u8,
        pdcm: u8,
        rsvd0: u8,
        pcid: u8,
        dca: u8,
        sse4dot1: u8,
        sse4dot2: u8,
        x2apic: u8,
        movbe: u8,
        popcnt: u8,
        tsc_dline: u8,
        aesni: u8,
        xsave: u8,
        osxsave: u8,
        avx: u8,
        f16c: u8,
        rdrand: u8,
        notused: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sse3: u8 = unsafe { ::core::mem::transmute(sse3) };
            sse3 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pclmuldq: u8 = unsafe { ::core::mem::transmute(pclmuldq) };
            pclmuldq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dtest64: u8 = unsafe { ::core::mem::transmute(dtest64) };
            dtest64 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let monitor: u8 = unsafe { ::core::mem::transmute(monitor) };
            monitor as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ds_cpl: u8 = unsafe { ::core::mem::transmute(ds_cpl) };
            ds_cpl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let vmx: u8 = unsafe { ::core::mem::transmute(vmx) };
            vmx as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let smx: u8 = unsafe { ::core::mem::transmute(smx) };
            smx as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let eist: u8 = unsafe { ::core::mem::transmute(eist) };
            eist as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tm2: u8 = unsafe { ::core::mem::transmute(tm2) };
            tm2 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ssse3: u8 = unsafe { ::core::mem::transmute(ssse3) };
            ssse3 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cnxt_id: u8 = unsafe { ::core::mem::transmute(cnxt_id) };
            cnxt_id as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sdbg: u8 = unsafe { ::core::mem::transmute(sdbg) };
            sdbg as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fma: u8 = unsafe { ::core::mem::transmute(fma) };
            fma as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let cx16: u8 = unsafe { ::core::mem::transmute(cx16) };
            cx16 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let xtpr: u8 = unsafe { ::core::mem::transmute(xtpr) };
            xtpr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pdcm: u8 = unsafe { ::core::mem::transmute(pdcm) };
            pdcm as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pcid: u8 = unsafe { ::core::mem::transmute(pcid) };
            pcid as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let dca: u8 = unsafe { ::core::mem::transmute(dca) };
            dca as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sse4dot1: u8 = unsafe { ::core::mem::transmute(sse4dot1) };
            sse4dot1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sse4dot2: u8 = unsafe { ::core::mem::transmute(sse4dot2) };
            sse4dot2 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let x2apic: u8 = unsafe { ::core::mem::transmute(x2apic) };
            x2apic as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let movbe: u8 = unsafe { ::core::mem::transmute(movbe) };
            movbe as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let popcnt: u8 = unsafe { ::core::mem::transmute(popcnt) };
            popcnt as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tsc_dline: u8 = unsafe { ::core::mem::transmute(tsc_dline) };
            tsc_dline as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let aesni: u8 = unsafe { ::core::mem::transmute(aesni) };
            aesni as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let xsave: u8 = unsafe { ::core::mem::transmute(xsave) };
            xsave as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let osxsave: u8 = unsafe { ::core::mem::transmute(osxsave) };
            osxsave as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let avx: u8 = unsafe { ::core::mem::transmute(avx) };
            avx as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let f16c: u8 = unsafe { ::core::mem::transmute(f16c) };
            f16c as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rdrand: u8 = unsafe { ::core::mem::transmute(rdrand) };
            rdrand as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let notused: u8 = unsafe { ::core::mem::transmute(notused) };
            notused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_cpuid_ecx_flags__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_ecx_flags__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_ecx_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_ecx_flags__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_ecx_flags__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpuid_ecx_flags__bindgen_ty_1>())).val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ecx_flags__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_cpuid_ecx_flags() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_ecx_flags>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_ecx_flags))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_ecx_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_ecx_flags))
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct cpuid_edx_flags {
    pub __bindgen_anon_1: cpuid_edx_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union cpuid_edx_flags__bindgen_ty_1 {
    pub val: u32,
    pub __bindgen_anon_1: cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl cpuid_edx_flags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn fpu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fpu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vme(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vme(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn de(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_de(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pse(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pse(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tsc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pae(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pae(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mce(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mce(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cx8(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cx8(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apic(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_apic(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sep(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sep(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mtrr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mtrr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mca(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mca(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmov(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cmov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pse_36(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pse_36(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psn(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_psn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clfsh(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_clfsh(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ds(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ds(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acpi(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_acpi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fxsr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fxsr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sse(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sse2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ss(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ss(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn htt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_htt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pbe(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pbe(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fpu: u8,
        vme: u8,
        de: u8,
        pse: u8,
        tsc: u8,
        msr: u8,
        pae: u8,
        mce: u8,
        cx8: u8,
        apic: u8,
        rsvd0: u8,
        sep: u8,
        mtrr: u8,
        pge: u8,
        mca: u8,
        cmov: u8,
        pat: u8,
        pse_36: u8,
        psn: u8,
        clfsh: u8,
        rsvd1: u8,
        ds: u8,
        acpi: u8,
        mmx: u8,
        fxsr: u8,
        sse: u8,
        sse2: u8,
        ss: u8,
        htt: u8,
        tm: u8,
        rsvd2: u8,
        pbe: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fpu: u8 = unsafe { ::core::mem::transmute(fpu) };
            fpu as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let vme: u8 = unsafe { ::core::mem::transmute(vme) };
            vme as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let de: u8 = unsafe { ::core::mem::transmute(de) };
            de as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pse: u8 = unsafe { ::core::mem::transmute(pse) };
            pse as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tsc: u8 = unsafe { ::core::mem::transmute(tsc) };
            tsc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let msr: u8 = unsafe { ::core::mem::transmute(msr) };
            msr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pae: u8 = unsafe { ::core::mem::transmute(pae) };
            pae as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mce: u8 = unsafe { ::core::mem::transmute(mce) };
            mce as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cx8: u8 = unsafe { ::core::mem::transmute(cx8) };
            cx8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let apic: u8 = unsafe { ::core::mem::transmute(apic) };
            apic as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sep: u8 = unsafe { ::core::mem::transmute(sep) };
            sep as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mtrr: u8 = unsafe { ::core::mem::transmute(mtrr) };
            mtrr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let pge: u8 = unsafe { ::core::mem::transmute(pge) };
            pge as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let mca: u8 = unsafe { ::core::mem::transmute(mca) };
            mca as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cmov: u8 = unsafe { ::core::mem::transmute(cmov) };
            cmov as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pat: u8 = unsafe { ::core::mem::transmute(pat) };
            pat as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pse_36: u8 = unsafe { ::core::mem::transmute(pse_36) };
            pse_36 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let psn: u8 = unsafe { ::core::mem::transmute(psn) };
            psn as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let clfsh: u8 = unsafe { ::core::mem::transmute(clfsh) };
            clfsh as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ds: u8 = unsafe { ::core::mem::transmute(ds) };
            ds as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let acpi: u8 = unsafe { ::core::mem::transmute(acpi) };
            acpi as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let mmx: u8 = unsafe { ::core::mem::transmute(mmx) };
            mmx as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let fxsr: u8 = unsafe { ::core::mem::transmute(fxsr) };
            fxsr as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let sse: u8 = unsafe { ::core::mem::transmute(sse) };
            sse as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sse2: u8 = unsafe { ::core::mem::transmute(sse2) };
            sse2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let ss: u8 = unsafe { ::core::mem::transmute(ss) };
            ss as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let htt: u8 = unsafe { ::core::mem::transmute(htt) };
            htt as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let tm: u8 = unsafe { ::core::mem::transmute(tm) };
            tm as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rsvd2: u8 = unsafe { ::core::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pbe: u8 = unsafe { ::core::mem::transmute(pbe) };
            pbe as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_cpuid_edx_flags__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_edx_flags__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_edx_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_edx_flags__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_edx_flags__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpuid_edx_flags__bindgen_ty_1>())).val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_edx_flags__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_cpuid_edx_flags() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_edx_flags>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_edx_flags))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_edx_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_edx_flags))
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct cpuid_amd_ecx_flags {
    pub __bindgen_anon_1: cpuid_amd_ecx_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union cpuid_amd_ecx_flags__bindgen_ty_1 {
    pub val: u32,
    pub __bindgen_anon_1: cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub rsvd3: u8,
}
#[test]
fn bindgen_test_layout_cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1>())).rsvd3
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsvd3)
        )
    );
}
impl cpuid_amd_ecx_flags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn lahfsahf(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lahfsahf(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmplegacy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cmplegacy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_svm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extapicspace(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extapicspace(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn altmovcr8(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_altmovcr8(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn abm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_abm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4a(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sse4a(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn misalignsse(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_misalignsse(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prefetch3d(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_prefetch3d(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn osvw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_osvw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ibs(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ibs(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skinit(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skinit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wdt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wdt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lwp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lwp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fma4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fma4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn nodeid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nodeid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tbm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tbm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn topext(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_topext(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lahfsahf: u8,
        cmplegacy: u8,
        svm: u8,
        extapicspace: u8,
        altmovcr8: u8,
        abm: u8,
        sse4a: u8,
        misalignsse: u8,
        prefetch3d: u8,
        osvw: u8,
        ibs: u8,
        xop: u8,
        skinit: u8,
        wdt: u8,
        rsvd0: u8,
        lwp: u8,
        fma4: u8,
        rsvd1: u8,
        nodeid: u8,
        rsvd2: u8,
        tbm: u8,
        topext: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lahfsahf: u8 = unsafe { ::core::mem::transmute(lahfsahf) };
            lahfsahf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cmplegacy: u8 = unsafe { ::core::mem::transmute(cmplegacy) };
            cmplegacy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let svm: u8 = unsafe { ::core::mem::transmute(svm) };
            svm as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let extapicspace: u8 = unsafe { ::core::mem::transmute(extapicspace) };
            extapicspace as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let altmovcr8: u8 = unsafe { ::core::mem::transmute(altmovcr8) };
            altmovcr8 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let abm: u8 = unsafe { ::core::mem::transmute(abm) };
            abm as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sse4a: u8 = unsafe { ::core::mem::transmute(sse4a) };
            sse4a as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let misalignsse: u8 = unsafe { ::core::mem::transmute(misalignsse) };
            misalignsse as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let prefetch3d: u8 = unsafe { ::core::mem::transmute(prefetch3d) };
            prefetch3d as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let osvw: u8 = unsafe { ::core::mem::transmute(osvw) };
            osvw as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ibs: u8 = unsafe { ::core::mem::transmute(ibs) };
            ibs as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let xop: u8 = unsafe { ::core::mem::transmute(xop) };
            xop as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let skinit: u8 = unsafe { ::core::mem::transmute(skinit) };
            skinit as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let wdt: u8 = unsafe { ::core::mem::transmute(wdt) };
            wdt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let lwp: u8 = unsafe { ::core::mem::transmute(lwp) };
            lwp as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let fma4: u8 = unsafe { ::core::mem::transmute(fma4) };
            fma4 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let nodeid: u8 = unsafe { ::core::mem::transmute(nodeid) };
            nodeid as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rsvd2: u8 = unsafe { ::core::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tbm: u8 = unsafe { ::core::mem::transmute(tbm) };
            tbm as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let topext: u8 = unsafe { ::core::mem::transmute(topext) };
            topext as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_cpuid_amd_ecx_flags__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_amd_ecx_flags__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_amd_ecx_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_amd_ecx_flags__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_amd_ecx_flags__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpuid_amd_ecx_flags__bindgen_ty_1>())).val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_amd_ecx_flags__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_cpuid_amd_ecx_flags() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_amd_ecx_flags>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_amd_ecx_flags))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_amd_ecx_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_amd_ecx_flags))
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct cpuid_amd_edx_flags {
    pub __bindgen_anon_1: cpuid_amd_edx_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union cpuid_amd_edx_flags__bindgen_ty_1 {
    pub val: u32,
    pub __bindgen_anon_1: cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl cpuid_amd_edx_flags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn fpu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fpu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vme(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vme(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn de(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_de(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pse(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pse(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tsc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pae(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pae(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mce(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mce(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmpxchg8b(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cmpxchg8b(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apic(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_apic(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscall(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscall(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mtrr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mtrr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mca(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mca(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmov(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cmov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pse36(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pse36(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn nx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmx_ext(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmx_ext(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fxsr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fxsr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ffxsr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ffxsr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pg1gb(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pg1gb(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdtscp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rdtscp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amd3dnowext(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_amd3dnowext(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amd3dnow(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_amd3dnow(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fpu: u8,
        vme: u8,
        de: u8,
        pse: u8,
        tsc: u8,
        msr: u8,
        pae: u8,
        mce: u8,
        cmpxchg8b: u8,
        apic: u8,
        rsvd0: u8,
        syscall: u8,
        mtrr: u8,
        pge: u8,
        mca: u8,
        cmov: u8,
        pat: u8,
        pse36: u8,
        rsvd1: u8,
        nx: u8,
        rsvd2: u8,
        mmx_ext: u8,
        mmx: u8,
        fxsr: u8,
        ffxsr: u8,
        pg1gb: u8,
        rdtscp: u8,
        rsvd3: u8,
        lm: u8,
        amd3dnowext: u8,
        amd3dnow: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fpu: u8 = unsafe { ::core::mem::transmute(fpu) };
            fpu as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let vme: u8 = unsafe { ::core::mem::transmute(vme) };
            vme as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let de: u8 = unsafe { ::core::mem::transmute(de) };
            de as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pse: u8 = unsafe { ::core::mem::transmute(pse) };
            pse as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tsc: u8 = unsafe { ::core::mem::transmute(tsc) };
            tsc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let msr: u8 = unsafe { ::core::mem::transmute(msr) };
            msr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pae: u8 = unsafe { ::core::mem::transmute(pae) };
            pae as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mce: u8 = unsafe { ::core::mem::transmute(mce) };
            mce as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cmpxchg8b: u8 = unsafe { ::core::mem::transmute(cmpxchg8b) };
            cmpxchg8b as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let apic: u8 = unsafe { ::core::mem::transmute(apic) };
            apic as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let syscall: u8 = unsafe { ::core::mem::transmute(syscall) };
            syscall as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mtrr: u8 = unsafe { ::core::mem::transmute(mtrr) };
            mtrr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let pge: u8 = unsafe { ::core::mem::transmute(pge) };
            pge as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let mca: u8 = unsafe { ::core::mem::transmute(mca) };
            mca as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cmov: u8 = unsafe { ::core::mem::transmute(cmov) };
            cmov as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pat: u8 = unsafe { ::core::mem::transmute(pat) };
            pat as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pse36: u8 = unsafe { ::core::mem::transmute(pse36) };
            pse36 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let nx: u8 = unsafe { ::core::mem::transmute(nx) };
            nx as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rsvd2: u8 = unsafe { ::core::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let mmx_ext: u8 = unsafe { ::core::mem::transmute(mmx_ext) };
            mmx_ext as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let mmx: u8 = unsafe { ::core::mem::transmute(mmx) };
            mmx as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let fxsr: u8 = unsafe { ::core::mem::transmute(fxsr) };
            fxsr as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ffxsr: u8 = unsafe { ::core::mem::transmute(ffxsr) };
            ffxsr as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let pg1gb: u8 = unsafe { ::core::mem::transmute(pg1gb) };
            pg1gb as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rdtscp: u8 = unsafe { ::core::mem::transmute(rdtscp) };
            rdtscp as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rsvd3: u8 = unsafe { ::core::mem::transmute(rsvd3) };
            rsvd3 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let lm: u8 = unsafe { ::core::mem::transmute(lm) };
            lm as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let amd3dnowext: u8 = unsafe { ::core::mem::transmute(amd3dnowext) };
            amd3dnowext as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let amd3dnow: u8 = unsafe { ::core::mem::transmute(amd3dnow) };
            amd3dnow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_cpuid_amd_edx_flags__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_amd_edx_flags__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_amd_edx_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_amd_edx_flags__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_amd_edx_flags__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpuid_amd_edx_flags__bindgen_ty_1>())).val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_amd_edx_flags__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_cpuid_amd_edx_flags() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_amd_edx_flags>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_amd_edx_flags))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_amd_edx_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_amd_edx_flags))
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct cpuid_ext_feat_flags_ebx {
    pub __bindgen_anon_1: cpuid_ext_feat_flags_ebx__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union cpuid_ext_feat_flags_ebx__bindgen_ty_1 {
    pub val: u32,
    pub __bindgen_anon_1: cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub rsvd3: u16,
}
#[test]
fn bindgen_test_layout_cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1>())).rsvd3
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsvd3)
        )
    );
}
impl cpuid_ext_feat_flags_ebx__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn fsgsbase(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsgsbase(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn bmi1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bmi1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hle(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hle(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_avx2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smep(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_smep(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bmi2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bmi2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn erms(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_erms(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invpcid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_invpcid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rtm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fsgsbase: u8,
        rsvd0: u8,
        bmi1: u8,
        hle: u8,
        avx2: u8,
        smep: u8,
        rsvd1: u8,
        bmi2: u8,
        erms: u8,
        invpcid: u8,
        rtm: u8,
        rsvd2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fsgsbase: u8 = unsafe { ::core::mem::transmute(fsgsbase) };
            fsgsbase as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bmi1: u8 = unsafe { ::core::mem::transmute(bmi1) };
            bmi1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hle: u8 = unsafe { ::core::mem::transmute(hle) };
            hle as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let avx2: u8 = unsafe { ::core::mem::transmute(avx2) };
            avx2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let smep: u8 = unsafe { ::core::mem::transmute(smep) };
            smep as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bmi2: u8 = unsafe { ::core::mem::transmute(bmi2) };
            bmi2 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let erms: u8 = unsafe { ::core::mem::transmute(erms) };
            erms as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let invpcid: u8 = unsafe { ::core::mem::transmute(invpcid) };
            invpcid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rtm: u8 = unsafe { ::core::mem::transmute(rtm) };
            rtm as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let rsvd2: u8 = unsafe { ::core::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_cpuid_ext_feat_flags_ebx__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_ext_feat_flags_ebx__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(cpuid_ext_feat_flags_ebx__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_ext_feat_flags_ebx__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(cpuid_ext_feat_flags_ebx__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpuid_ext_feat_flags_ebx__bindgen_ty_1>())).val as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ext_feat_flags_ebx__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_cpuid_ext_feat_flags_ebx() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_ext_feat_flags_ebx>(),
        4usize,
        concat!("Size of: ", stringify!(cpuid_ext_feat_flags_ebx))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_ext_feat_flags_ebx>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_ext_feat_flags_ebx))
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct cpuid_feature_flags {
    pub ecx: cpuid_ecx_flags,
    pub edx: cpuid_edx_flags,
}
#[test]
fn bindgen_test_layout_cpuid_feature_flags() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_feature_flags>(),
        8usize,
        concat!("Size of: ", stringify!(cpuid_feature_flags))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_feature_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(cpuid_feature_flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuid_feature_flags>())).ecx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_feature_flags),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuid_feature_flags>())).edx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_feature_flags),
            "::",
            stringify!(edx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_ret {
    pub a: u32,
    pub b: u32,
    pub c: u32,
    pub d: u32,
}
#[test]
fn bindgen_test_layout_cpuid_ret() {
    assert_eq!(
        ::core::mem::size_of::<cpuid_ret>(),
        16usize,
        concat!("Size of: ", stringify!(cpuid_ret))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuid_ret>(),
        4usize,
        concat!("Alignment of ", stringify!(cpuid_ret))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuid_ret>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuid_ret>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuid_ret>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuid_ret>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret),
            "::",
            stringify!(d)
        )
    );
}
pub type cpuid_ret_t = cpuid_ret;
