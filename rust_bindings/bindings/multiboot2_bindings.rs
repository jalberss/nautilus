/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__: &'static [u8; 28usize] = b"8.0.1 (branches/release_80)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Clang 8.0.1 (branches/release_80)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const MULTIBOOT_HEADER: u32 = 1;
pub const MULTIBOOT_SEARCH: u32 = 32768;
pub const MULTIBOOT_HEADER_ALIGN: u32 = 8;
pub const MULTIBOOT2_HEADER_MAGIC: u32 = 3897708758;
pub const MULTIBOOT2_BOOTLOADER_MAGIC: u32 = 920085129;
pub const MULTIBOOT_MOD_ALIGN: u32 = 4096;
pub const MULTIBOOT_INFO_ALIGN: u32 = 8;
pub const MULTIBOOT_TAG_ALIGN: u32 = 8;
pub const MULTIBOOT_TAG_TYPE_END: u32 = 0;
pub const MULTIBOOT_TAG_TYPE_CMDLINE: u32 = 1;
pub const MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME: u32 = 2;
pub const MULTIBOOT_TAG_TYPE_MODULE: u32 = 3;
pub const MULTIBOOT_TAG_TYPE_BASIC_MEMINFO: u32 = 4;
pub const MULTIBOOT_TAG_TYPE_BOOTDEV: u32 = 5;
pub const MULTIBOOT_TAG_TYPE_MMAP: u32 = 6;
pub const MULTIBOOT_TAG_TYPE_VBE: u32 = 7;
pub const MULTIBOOT_TAG_TYPE_FRAMEBUFFER: u32 = 8;
pub const MULTIBOOT_TAG_TYPE_ELF_SECTIONS: u32 = 9;
pub const MULTIBOOT_TAG_TYPE_APM: u32 = 10;
pub const MULTIBOOT_TAG_TYPE_EFI32: u32 = 11;
pub const MULTIBOOT_TAG_TYPE_EFI64: u32 = 12;
pub const MULTIBOOT_TAG_TYPE_SMBIOS: u32 = 13;
pub const MULTIBOOT_TAG_TYPE_ACPI_OLD: u32 = 14;
pub const MULTIBOOT_TAG_TYPE_ACPI_NEW: u32 = 15;
pub const MULTIBOOT_TAG_TYPE_NETWORK: u32 = 16;
pub const MULTIBOOT_TAG_TYPE_EFI_MEM_MAP: u32 = 17;
pub const MULTIBOOT_TAG_TYPE_EFI_BOOT_SERV: u32 = 18;
pub const MULTIBOOT_TAG_TYPE_EFI_32B_HANDLE: u32 = 19;
pub const MULTIBOOT_TAG_TYPE_EFI_64B_HANDLE: u32 = 20;
pub const MULTIBOOT_TAG_TYPE_IMAGE_BASE: u32 = 21;
pub const MULTIBOOT_TAG_TYPE_HRT: u32 = 4027445261;
pub const MULTIBOOT_HEADER_TAG_END: u32 = 0;
pub const MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST: u32 = 1;
pub const MULTIBOOT_HEADER_TAG_ADDRESS: u32 = 2;
pub const MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS: u32 = 3;
pub const MULTIBOOT_HEADER_TAG_CONSOLE_FLAGS: u32 = 4;
pub const MULTIBOOT_HEADER_TAG_FRAMEBUFFER: u32 = 5;
pub const MULTIBOOT_HEADER_TAG_MODULE_ALIGN: u32 = 6;
pub const MULTIBOOT_ARCHITECTURE_I386: u32 = 0;
pub const MULTIBOOT_ARCHITECTURE_MIPS32: u32 = 4;
pub const MULTIBOOT_HEADER_TAG_OPTIONAL: u32 = 1;
pub const MULTIBOOT_CONSOLE_FLAGS_CONSOLE_REQUIRED: u32 = 1;
pub const MULTIBOOT_CONSOLE_FLAGS_EGA_TEXT_SUPPORTED: u32 = 2;
pub const MULTIBOOT_MEMORY_AVAILABLE: u32 = 1;
pub const MULTIBOOT_MEMORY_RESERVED: u32 = 2;
pub const MULTIBOOT_MEMORY_ACPI_RECLAIMABLE: u32 = 3;
pub const MULTIBOOT_MEMORY_NVS: u32 = 4;
pub const MULTIBOOT_MEMORY_BADRAM: u32 = 5;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_INDEXED: u32 = 0;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_RGB: u32 = 1;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT: u32 = 2;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type schar_t = ::libc::c_schar;
pub type uchar_t = ::libc::c_uchar;
pub type sshort_t = ::libc::c_short;
pub type ushort_t = ::libc::c_ushort;
pub type sint_t = ::libc::c_int;
pub type uint_t = ::libc::c_uint;
pub type sllong_t = ::libc::c_longlong;
pub type ullong_t = ::libc::c_ulonglong;
pub type slong_t = ::libc::c_long;
pub type ulong_t = ::libc::c_ulong;
pub type off_t = ::libc::c_ulong;
pub type sint64_t = ::libc::c_long;
pub type sint32_t = ::libc::c_int;
pub type sint16_t = ::libc::c_short;
pub type sint8_t = ::libc::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
pub type multiboot_uint8_t = ::libc::c_uchar;
pub type multiboot_uint16_t = ::libc::c_ushort;
pub type multiboot_uint32_t = ::libc::c_uint;
pub type multiboot_uint64_t = ::libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header {
    pub magic: multiboot_uint32_t,
    pub architecture: multiboot_uint32_t,
    pub header_length: multiboot_uint32_t,
    pub checksum: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_header))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).architecture as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(architecture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).header_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(header_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).checksum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(checksum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_header_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_header_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header_tag>())).flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header_tag>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_header_tag_information_request {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub requests: __IncompleteArrayField<multiboot_uint32_t>,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_information_request() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_information_request>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_header_tag_information_request)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_information_request>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_information_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).requests
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(requests)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_address {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub header_addr: multiboot_uint32_t,
    pub load_addr: multiboot_uint32_t,
    pub load_end_addr: multiboot_uint32_t,
    pub bss_end_addr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_address() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_address>(),
        24usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_address))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_address>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_header_tag_address))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).flags as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).header_addr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(header_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).load_addr as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(load_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).load_end_addr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(load_end_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).bss_end_addr as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(bss_end_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_entry_address {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub entry_addr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_entry_address() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_entry_address>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_entry_address))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_entry_address>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_entry_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).entry_addr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(entry_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_console_flags {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub console_flags: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_console_flags() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_console_flags>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_console_flags))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_console_flags>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_console_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).console_flags
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(console_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_framebuffer {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub width: multiboot_uint32_t,
    pub height: multiboot_uint32_t,
    pub depth: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_framebuffer() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_framebuffer>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_framebuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_framebuffer>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).flags as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_module_align {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub width: multiboot_uint32_t,
    pub height: multiboot_uint32_t,
    pub depth: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_module_align() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_module_align>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_module_align))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_module_align>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_module_align)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).width as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).depth as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_color {
    pub red: multiboot_uint8_t,
    pub green: multiboot_uint8_t,
    pub blue: multiboot_uint8_t,
}
#[test]
fn bindgen_test_layout_multiboot_color() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_color>(),
        3usize,
        concat!("Size of: ", stringify!(multiboot_color))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_color>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_color))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_color>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_color),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_color>())).green as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_color),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_color>())).blue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_color),
            "::",
            stringify!(blue)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_mmap_entry {
    pub addr: multiboot_uint64_t,
    pub len: multiboot_uint64_t,
    pub type_: multiboot_uint32_t,
    pub zero: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_mmap_entry() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_mmap_entry>(),
        24usize,
        concat!("Size of: ", stringify!(multiboot_mmap_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_mmap_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_mmap_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).zero as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(zero)
        )
    );
}
pub type multiboot_memory_map_t = multiboot_mmap_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_string {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub string: __IncompleteArrayField<::libc::c_char>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_string() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_string>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_string))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_string>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_string))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_string>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_string),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_string>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_string),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_string>())).string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_string),
            "::",
            stringify!(string)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_module {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub mod_start: multiboot_uint32_t,
    pub mod_end: multiboot_uint32_t,
    pub cmdline: __IncompleteArrayField<::libc::c_char>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_module() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_module>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_module))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_module>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_module))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).mod_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(mod_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).mod_end as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(mod_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).cmdline as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(cmdline)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_basic_meminfo {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub mem_lower: multiboot_uint32_t,
    pub mem_upper: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_basic_meminfo() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_basic_meminfo>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_basic_meminfo))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_basic_meminfo>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_basic_meminfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).mem_lower as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(mem_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).mem_upper as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(mem_upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_bootdev {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub biosdev: multiboot_uint32_t,
    pub slice: multiboot_uint32_t,
    pub part: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_bootdev() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_bootdev>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_tag_bootdev))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_bootdev>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_bootdev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).biosdev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(biosdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).slice as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).part as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(part)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_mmap {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub entry_size: multiboot_uint32_t,
    pub entry_version: multiboot_uint32_t,
    pub entries: __IncompleteArrayField<multiboot_mmap_entry>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_mmap() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_mmap>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_mmap))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_mmap>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_mmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).entry_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(entry_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_mmap>())).entry_version as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(entry_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiboot_vbe_info_block {
    pub external_specification: [multiboot_uint8_t; 512usize],
}
#[test]
fn bindgen_test_layout_multiboot_vbe_info_block() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_vbe_info_block>(),
        512usize,
        concat!("Size of: ", stringify!(multiboot_vbe_info_block))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_vbe_info_block>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_vbe_info_block))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_vbe_info_block>())).external_specification as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_vbe_info_block),
            "::",
            stringify!(external_specification)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiboot_vbe_mode_info_block {
    pub external_specification: [multiboot_uint8_t; 256usize],
}
#[test]
fn bindgen_test_layout_multiboot_vbe_mode_info_block() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_vbe_mode_info_block>(),
        256usize,
        concat!("Size of: ", stringify!(multiboot_vbe_mode_info_block))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_vbe_mode_info_block>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_vbe_mode_info_block))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_vbe_mode_info_block>())).external_specification
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_vbe_mode_info_block),
            "::",
            stringify!(external_specification)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiboot_tag_vbe {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub vbe_mode: multiboot_uint16_t,
    pub vbe_interface_seg: multiboot_uint16_t,
    pub vbe_interface_off: multiboot_uint16_t,
    pub vbe_interface_len: multiboot_uint16_t,
    pub vbe_control_info: multiboot_vbe_info_block,
    pub vbe_mode_info: multiboot_vbe_mode_info_block,
}
#[test]
fn bindgen_test_layout_multiboot_tag_vbe() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_vbe>(),
        784usize,
        concat!("Size of: ", stringify!(multiboot_tag_vbe))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_vbe>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_vbe))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_vbe>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_vbe>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_interface_seg as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_interface_seg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_interface_off as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_interface_off)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_interface_len as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_interface_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_control_info as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_control_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_mode_info as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_mode_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_framebuffer_common {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub framebuffer_addr: multiboot_uint64_t,
    pub framebuffer_pitch: multiboot_uint32_t,
    pub framebuffer_width: multiboot_uint32_t,
    pub framebuffer_height: multiboot_uint32_t,
    pub framebuffer_bpp: multiboot_uint8_t,
    pub framebuffer_type: multiboot_uint8_t,
    pub reserved: multiboot_uint16_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer_common() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer_common>(),
        32usize,
        concat!("Size of: ", stringify!(multiboot_tag_framebuffer_common))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer_common>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer_common)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_addr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_pitch
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_width
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_height
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_bpp
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_bpp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_type
                as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).reserved as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
pub struct multiboot_tag_framebuffer {
    pub common: multiboot_tag_framebuffer_common,
    pub __bindgen_anon_1: multiboot_tag_framebuffer__bindgen_ty_1,
}
#[repr(C)]
pub struct multiboot_tag_framebuffer__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2:
        __BindgenUnionField<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u16; 3usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1 {
    pub framebuffer_palette_num_colors: multiboot_uint16_t,
    pub framebuffer_palette: __IncompleteArrayField<multiboot_color>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>()))
                .framebuffer_palette_num_colors as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(framebuffer_palette_num_colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>()))
                .framebuffer_palette as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(framebuffer_palette)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2 {
    pub framebuffer_red_field_position: multiboot_uint8_t,
    pub framebuffer_red_mask_size: multiboot_uint8_t,
    pub framebuffer_green_field_position: multiboot_uint8_t,
    pub framebuffer_green_mask_size: multiboot_uint8_t,
    pub framebuffer_blue_field_position: multiboot_uint8_t,
    pub framebuffer_blue_mask_size: multiboot_uint8_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_red_field_position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_red_field_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_red_mask_size as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_red_mask_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_green_field_position as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_green_field_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_green_mask_size as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_green_mask_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_blue_field_position as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_blue_field_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_blue_mask_size as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_blue_mask_size)
        )
    );
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer__bindgen_ty_1>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer>(),
        40usize,
        concat!("Size of: ", stringify!(multiboot_tag_framebuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_tag_framebuffer))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer>())).common as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer),
            "::",
            stringify!(common)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_elf_sections {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub num: multiboot_uint32_t,
    pub entsize: multiboot_uint32_t,
    pub shndx: multiboot_uint32_t,
    pub sections: __IncompleteArrayField<::libc::c_char>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_elf_sections() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_elf_sections>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_tag_elf_sections))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_elf_sections>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_elf_sections))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).entsize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(entsize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).shndx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(shndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).sections as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(sections)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_apm {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub version: multiboot_uint16_t,
    pub cseg: multiboot_uint16_t,
    pub offset: multiboot_uint32_t,
    pub cseg_16: multiboot_uint16_t,
    pub dseg: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub cseg_len: multiboot_uint16_t,
    pub cseg_16_len: multiboot_uint16_t,
    pub dseg_len: multiboot_uint16_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_apm() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_apm>(),
        28usize,
        concat!("Size of: ", stringify!(multiboot_tag_apm))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_apm>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_apm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg_16 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).dseg as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(dseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg_len as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg_16_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg_16_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).dseg_len as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(dseg_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi32 {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub pointer: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi32() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi32>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi32))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi32>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi32>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi32),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi32>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi32),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi32>())).pointer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi32),
            "::",
            stringify!(pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi64 {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub pointer: multiboot_uint64_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi64() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi64>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi64))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi64>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi64>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi64),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi64>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi64),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi64>())).pointer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi64),
            "::",
            stringify!(pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_smbios {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub major: multiboot_uint8_t,
    pub minor: multiboot_uint8_t,
    pub reserved: [multiboot_uint8_t; 6usize],
    pub tables: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_smbios() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_smbios>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_smbios))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_smbios>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_smbios))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).major as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).minor as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).reserved as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).tables as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(tables)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_old_acpi {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub rsdp: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_old_acpi() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_old_acpi>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_old_acpi))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_old_acpi>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_old_acpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_old_acpi>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_old_acpi),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_old_acpi>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_old_acpi),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_old_acpi>())).rsdp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_old_acpi),
            "::",
            stringify!(rsdp)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_new_acpi {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub rsdp: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_new_acpi() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_new_acpi>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_new_acpi))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_new_acpi>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_new_acpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_new_acpi>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_new_acpi),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_new_acpi>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_new_acpi),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_new_acpi>())).rsdp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_new_acpi),
            "::",
            stringify!(rsdp)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_network {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub dhcpack: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_network() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_network>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_network))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_network>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_network))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_network>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_network),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_network>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_network),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_network>())).dhcpack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_network),
            "::",
            stringify!(dhcpack)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_efi_mem_map {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub desc_size: multiboot_uint32_t,
    pub desc_version: multiboot_uint32_t,
    pub efi_mem_map: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_mem_map() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_mem_map>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_mem_map))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_mem_map>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_mem_map))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).desc_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(desc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).desc_version as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(desc_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).efi_mem_map as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(efi_mem_map)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi_boot_serv {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_boot_serv() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_boot_serv>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_boot_serv))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_boot_serv>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_boot_serv))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_boot_serv>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_boot_serv),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_boot_serv>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_boot_serv),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi_32b_image {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub ptr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_32b_image() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_32b_image>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_32b_image))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_32b_image>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_32b_image))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_32b_image>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_32b_image),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_32b_image>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_32b_image),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_32b_image>())).ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_32b_image),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi_64b_image {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub ptr: multiboot_uint64_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_64b_image() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_64b_image>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_64b_image))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_64b_image>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_64b_image))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_64b_image>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_64b_image),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_64b_image>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_64b_image),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_64b_image>())).ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_64b_image),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_image_load_base {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub addr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_image_load_base() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_image_load_base>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_tag_image_load_base))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_image_load_base>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_image_load_base))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_image_load_base>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_image_load_base),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_image_load_base>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_image_load_base),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_image_load_base>())).addr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_image_load_base),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_hrt {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub total_num_apics: multiboot_uint32_t,
    pub first_hrt_apic_id: multiboot_uint32_t,
    pub have_hrt_ioapic: multiboot_uint32_t,
    pub first_hrt_ioapic_entry: multiboot_uint32_t,
    pub cpu_freq_khz: multiboot_uint64_t,
    pub hrt_flags: multiboot_uint64_t,
    pub max_mem_mapped: multiboot_uint64_t,
    pub first_hrt_gpa: multiboot_uint64_t,
    pub boot_state_gpa: multiboot_uint64_t,
    pub gva_offset: multiboot_uint64_t,
    pub comm_page_gpa: multiboot_uint64_t,
    pub hrt_int_vec: multiboot_uint8_t,
    pub reserved: [multiboot_uint8_t; 7usize],
}
#[test]
fn bindgen_test_layout_multiboot_tag_hrt() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_hrt>(),
        88usize,
        concat!("Size of: ", stringify!(multiboot_tag_hrt))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_hrt>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_tag_hrt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).total_num_apics as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(total_num_apics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).first_hrt_apic_id as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(first_hrt_apic_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).have_hrt_ioapic as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(have_hrt_ioapic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).first_hrt_ioapic_entry as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(first_hrt_ioapic_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).cpu_freq_khz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(cpu_freq_khz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).hrt_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(hrt_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).max_mem_mapped as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(max_mem_mapped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).first_hrt_gpa as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(first_hrt_gpa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).boot_state_gpa as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(boot_state_gpa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).gva_offset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(gva_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).comm_page_gpa as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(comm_page_gpa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).hrt_int_vec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(hrt_int_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).reserved as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(reserved)
        )
    );
}
