/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__: &'static [u8; 28usize] = b"8.0.1 (branches/release_80)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Clang 8.0.1 (branches/release_80)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NULL: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _D: u32 = 4;
pub const _C: u32 = 8;
pub const _P: u32 = 16;
pub const _S: u32 = 32;
pub const _X: u32 = 64;
pub const _SP: u32 = 128;
pub const NOP_1BYTE: u32 = 144;
pub const NUM_IDT_ENTRIES: u32 = 256;
pub const NUM_EXCEPTIONS: u32 = 32;
pub const DE_EXCP: u32 = 0;
pub const DB_EXCP: u32 = 1;
pub const NMI_INT: u32 = 2;
pub const BP_EXCP: u32 = 3;
pub const OF_EXCP: u32 = 4;
pub const BR_EXCP: u32 = 5;
pub const UD_EXCP: u32 = 6;
pub const NM_EXCP: u32 = 7;
pub const DF_EXCP: u32 = 8;
pub const CP_EXCP: u32 = 9;
pub const TS_EXCP: u32 = 10;
pub const NP_EXCP: u32 = 11;
pub const SS_EXCP: u32 = 12;
pub const GP_EXCP: u32 = 13;
pub const PF_EXCP: u32 = 14;
pub const MF_EXCP: u32 = 16;
pub const AC_EXCP: u32 = 17;
pub const MC_EXCP: u32 = 18;
pub const XM_EXCP: u32 = 19;
pub const VE_EXCP: u32 = 20;
pub const SE_EXCP: u32 = 30;
pub const ERR_CODE_EXCP_MASK: i32 = -4357377;
pub const KERNEL_CS: u32 = 8;
pub const KERNEL_DS: u32 = 16;
pub const KERNEL_SS: u32 = 16;
pub const PRINTK_BUFMAX: u32 = 128;
pub const __GNUC_VA_LIST: u32 = 1;
pub const IA32_TIME_STAMP_COUNTER: u32 = 16;
pub const IA32_MSR_EFER: u32 = 3221225600;
pub const IA32_MSR_APIC_BASE: u32 = 27;
pub const IA32_MISC_ENABLES: u32 = 416;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NXE: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const EFER_TCE: u32 = 32768;
pub const AMD_MSR_TSC: u32 = 16;
pub const AMD_MSR_APIC_BASE: u32 = 27;
pub const AMD_MSR_MPERF: u32 = 231;
pub const AMD_MSR_APERF: u32 = 232;
pub const AMD_MSR_MTRRCAP: u32 = 254;
pub const AMD_MSR_SYSENTER_CS: u32 = 372;
pub const AMD_MSR_SYSENTER_ESP: u32 = 373;
pub const AMD_MSR_SYSENTER_EIP: u32 = 374;
pub const AMD_MSR_MCG_CAP: u32 = 377;
pub const AMD_MSR_MCG_STATUS: u32 = 378;
pub const AMD_MSR_MCG_CTL: u32 = 379;
pub const AMD_MSR_DEBUG_CTL: u32 = 473;
pub const AMD_MSR_PAT: u32 = 631;
pub const AMD_MSR_STAR: u32 = 3221225601;
pub const AMD_MSR_LSTAR: u32 = 3221225602;
pub const AMD_MSR_CSTAR: u32 = 3221225603;
pub const AMD_MSR_SFMASK: u32 = 3221225604;
pub const AMD_MSR_FSBASE: u32 = 3221225728;
pub const AMD_MSR_GSBASE: u32 = 3221225729;
pub const AMD_MSR_KERN_GSBASE: u32 = 3221225730;
pub const AMD_MSR_TSC_AUX: u32 = 3221225731;
pub const AMD_MSR_SYSCFG: u32 = 3221291024;
pub const AMD_MSR_VM_CR: u32 = 3221291284;
pub const AMD_MSR_NBRIDGE_CTL: u32 = 3221291039;
pub const APIC_SPUR_INT_VEC: u32 = 255;
pub const APIC_TIMER_INT_VEC: u32 = 240;
pub const APIC_ERROR_INT_VEC: u32 = 241;
pub const APIC_THRML_INT_VEC: u32 = 242;
pub const APIC_PC_INT_VEC: u32 = 243;
pub const APIC_CMCR_INT_VEC: u32 = 244;
pub const APIC_EXT_LVT_DUMMY_VEC: u32 = 245;
pub const APIC_NULL_KICK_VEC: u32 = 252;
pub const APIC_TIMER_DIV: u32 = 16;
pub const APIC_TIMER_DIV_1: u32 = 11;
pub const APIC_TIMER_DIV_2: u32 = 0;
pub const APIC_TIMER_DIV_4: u32 = 1;
pub const APIC_TIMER_DIV_8: u32 = 2;
pub const APIC_TIMER_DIV_16: u32 = 3;
pub const APIC_TIMER_DIV_32: u32 = 8;
pub const APIC_TIMER_DIV_64: u32 = 9;
pub const APIC_TIMER_DIV_128: u32 = 10;
pub const APIC_TIMER_DIVCODE: u32 = 3;
pub const APIC_BASE_MSR: u32 = 27;
pub const IA32_APIC_BASE_MSR_BSP: u32 = 256;
pub const IA32_APIC_BASE_MSR_ENABLE: u32 = 2048;
pub const APIC_BASE_ADDR_MASK: i32 = -4096;
pub const APIC_IPI_SELF: u32 = 262144;
pub const APIC_IPI_ALL: u32 = 524288;
pub const APIC_IPI_OTHERS: u32 = 786432;
pub const APIC_GLOBAL_ENABLE: u32 = 2048;
pub const APIC_SPIV_SW_ENABLE: u32 = 256;
pub const APIC_SPIV_VEC_MASK: u32 = 255;
pub const APIC_SPIV_CORE_FOCUS: u32 = 512;
pub const APIC_SPIC_EOI_BROADCAST_DISABLE: u32 = 4096;
pub const ICR_DEL_MODE_LOWEST: u32 = 256;
pub const ICR_DEL_MODE_SMI: u32 = 512;
pub const ICR_DEL_MODE_NMI: u32 = 1024;
pub const ICR_DEL_MODE_INIT: u32 = 1280;
pub const ICR_DEL_MODE_STARTUP: u32 = 1536;
pub const ICR_DST_MODE_LOG: u32 = 2048;
pub const ICR_SEND_PENDING: u32 = 4096;
pub const ICR_LEVEL_ASSERT: u32 = 16384;
pub const ICR_TRIG_MODE_LEVEL: u32 = 32768;
pub const APIC_ID_SHIFT: u32 = 24;
pub const APIC_ICR2_DST_SHIFT: u32 = 24;
pub const APIC_REG_ID: u32 = 32;
pub const APIC_REG_LVR: u32 = 48;
pub const APIC_REG_TPR: u32 = 128;
pub const APIC_REG_APR: u32 = 144;
pub const APIC_REG_PPR: u32 = 160;
pub const APIC_REG_EOR: u32 = 176;
pub const APIC_REG_RRR: u32 = 192;
pub const APIC_REG_LDR: u32 = 208;
pub const APIC_REG_DFR: u32 = 224;
pub const APIC_REG_SPIV: u32 = 240;
pub const APIC_REG_ISR: u32 = 256;
pub const APIC_REG_TMR: u32 = 384;
pub const APIC_REG_IRR: u32 = 512;
pub const APIC_REG_ESR: u32 = 640;
pub const APIC_REG_LVT_CMCI: u32 = 752;
pub const APIC_REG_ICR: u32 = 768;
pub const APIC_ICR_BUSY: u32 = 4096;
pub const APIC_REG_ICR2: u32 = 784;
pub const APIC_REG_LVTT: u32 = 800;
pub const APIC_REG_LVTTHMR: u32 = 816;
pub const APIC_REG_LVTPC: u32 = 832;
pub const APIC_REG_LVT0: u32 = 848;
pub const APIC_REG_LVT1: u32 = 864;
pub const APIC_REG_LVTERR: u32 = 880;
pub const APIC_REG_TMICT: u32 = 896;
pub const APIC_REG_TMCCT: u32 = 912;
pub const APIC_REG_TMDCR: u32 = 992;
pub const APIC_REG_SELF_IPI: u32 = 1008;
pub const APIC_REG_EXFR: u32 = 1024;
pub const APIC_REG_EXFC: u32 = 1040;
pub const APIC_EXFC_XAIDC_EN: u32 = 4;
pub const APIC_EXFC_SN_EN: u32 = 2;
pub const APIC_EXFC_IERN: u32 = 1;
pub const X2APIC_MSR_ACCESS_BASE: u32 = 2048;
pub const APIC_DEL_MODE_FIXED: u32 = 0;
pub const APIC_DEL_MODE_LOWEST: u32 = 256;
pub const APIC_DEL_MODE_SMI: u32 = 512;
pub const APIC_DEL_MODE_REMRD: u32 = 768;
pub const APIC_DEL_MODE_NMI: u32 = 1024;
pub const APIC_DEL_MODE_INIT: u32 = 1280;
pub const APIC_DEL_MODE_SIPI: u32 = 1536;
pub const APIC_DEL_MODE_EXTINT: u32 = 1792;
pub const APIC_LVT_VEC_MASK: u32 = 255;
pub const APIC_LVT_DISABLED: u32 = 65536;
pub const APIC_DFR_FLAT: u32 = 4294967295;
pub const APIC_DFR_CLUSTER: u32 = 268435455;
pub const APIC_LDR_MASK: u32 = 4278190080;
pub const APIC_ALL_CPUS: u32 = 255;
pub const APIC_TIMER_MASK: u32 = 65536;
pub const APIC_TIMER_ONESHOT: u32 = 0;
pub const APIC_TIMER_PERIODIC: u32 = 131072;
pub const APIC_TIMER_TSCDLINE: u32 = 262144;
pub const IPI_VEC_XCALL: u32 = 243;
pub const RFLAGS_CF: u32 = 1;
pub const RFLAGS_PF: u32 = 4;
pub const RFLAGS_AF: u32 = 16;
pub const RFLAGS_ZF: u32 = 64;
pub const RFLAGS_SF: u32 = 128;
pub const RFLAGS_TF: u32 = 256;
pub const RFLAGS_IF: u32 = 512;
pub const RFLAGS_DF: u32 = 1024;
pub const RFLAGS_OF: u32 = 2048;
pub const RFLAGS_IOPL: u32 = 12288;
pub const RFLAGS_VM: u32 = 143360;
pub const RFLAGS_VIF: u32 = 524288;
pub const RFLAGS_VIP: u32 = 1048576;
pub const CR0_PE: u32 = 1;
pub const CR0_MP: u32 = 2;
pub const CR0_EM: u32 = 4;
pub const CR0_TS: u32 = 8;
pub const CR0_NE: u32 = 32;
pub const CR0_WP: u32 = 65536;
pub const CR0_AM: u32 = 262144;
pub const CR0_NW: u32 = 536870912;
pub const CR0_CD: u32 = 1073741824;
pub const CR0_PG: u32 = 2147483648;
pub const CR4_VME: u32 = 1;
pub const CR4_PVI: u32 = 2;
pub const CR4_TSD: u32 = 4;
pub const CR4_DE: u32 = 8;
pub const CR4_PSE: u32 = 16;
pub const CR4_PAE: u32 = 32;
pub const CR4_MCE: u32 = 64;
pub const CR4_PGE: u32 = 128;
pub const CR4_PCE: u32 = 256;
pub const CR4_OSFXSR: u32 = 512;
pub const CR4_OSXMMEXCPT: u32 = 1024;
pub const CR4_VMXE: u32 = 8192;
pub const CR4_XMXE: u32 = 16384;
pub const CR4_FSGSBASE: u32 = 65536;
pub const CR4_PCIDE: u32 = 131072;
pub const CR4_OSXSAVE: u32 = 262144;
pub const CR4_SMEP: u32 = 1048576;
pub const INSTR_CAL_LOOPS: u32 = 1000;
pub const SPINLOCK_INITIALIZER: u32 = 0;
pub const MAX_MMAP_ENTRIES: u32 = 128;
pub const AP_TRAMPOLINE_ADDR: u32 = 61440;
pub const AP_BOOT_STACK_ADDR: u32 = 4096;
pub const AP_INFO_AREA: u32 = 8192;
pub const BASE_MEM_LAST_KILO: u32 = 654336;
pub const BIOS_ROM_BASE: u32 = 983040;
pub const BIOS_ROM_END: u32 = 1048575;
pub const MEM_ZONE_UC: u32 = 1;
pub const MEM_ZONE_WC: u32 = 2;
pub const MEM_ZONE_WT: u32 = 4;
pub const MEM_ZONE_WB: u32 = 8;
pub const MEM_ZONE_UCE: u32 = 16;
pub const MEM_ZONE_WP: u32 = 4096;
pub const MEM_ZONE_RP: u32 = 8192;
pub const MEM_ZONE_XP: u32 = 16384;
pub const PAGE_SHIFT_4KB: u32 = 12;
pub const PAGE_SHIFT_2MB: u32 = 21;
pub const PAGE_SHIFT_1GB: u32 = 30;
pub const PAGE_SHIFT: u32 = 21;
pub const PAGE_SIZE_4KB: u32 = 4096;
pub const PAGE_SIZE_2MB: u32 = 2097152;
pub const PAGE_SIZE_1GB: u32 = 1073741824;
pub const PAGE_SIZE: u32 = 2097152;
pub const PAGE_MASK: i32 = -2097152;
pub const MEM_1GB: u32 = 1073741824;
pub const MEM_2MB: u32 = 2097152;
pub const NUM_PT_ENTRIES: u32 = 512;
pub const NUM_PD_ENTRIES: u32 = 512;
pub const NUM_PDPT_ENTRIES: u32 = 512;
pub const NUM_PML4_ENTRIES: u32 = 512;
pub const PML4_SHIFT: u32 = 39;
pub const PDPT_SHIFT: u32 = 30;
pub const PD_SHIFT: u32 = 21;
pub const PT_SHIFT: u32 = 12;
pub const PTE_ADDR_MASK: i32 = -4096;
pub const PTE_PRESENT_BIT: u32 = 1;
pub const PTE_WRITABLE_BIT: u32 = 2;
pub const PTE_KERNEL_ONLY_BIT: u32 = 4;
pub const PTE_WRITE_THROUGH_BIT: u32 = 8;
pub const PTE_CACHE_DISABLE_BIT: u32 = 16;
pub const PTE_ACCESSED_BIT: u32 = 32;
pub const PTE_DIRTY_BIT: u32 = 64;
pub const PTE_PAGE_SIZE_BIT: u32 = 128;
pub const PTE_GLOBAL_BIT: u32 = 256;
pub const PTE_PAT_BIT: u32 = 4096;
pub const PTE_NX_BIT: i64 = -9223372036854775808;
pub const HRT_HIHALF_OFFSET: u32 = 0;
pub const MULTIBOOT_HEADER: u32 = 1;
pub const MULTIBOOT_SEARCH: u32 = 32768;
pub const MULTIBOOT_HEADER_ALIGN: u32 = 8;
pub const MULTIBOOT2_HEADER_MAGIC: u32 = 3897708758;
pub const MULTIBOOT2_BOOTLOADER_MAGIC: u32 = 920085129;
pub const MULTIBOOT_MOD_ALIGN: u32 = 4096;
pub const MULTIBOOT_INFO_ALIGN: u32 = 8;
pub const MULTIBOOT_TAG_ALIGN: u32 = 8;
pub const MULTIBOOT_TAG_TYPE_END: u32 = 0;
pub const MULTIBOOT_TAG_TYPE_CMDLINE: u32 = 1;
pub const MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME: u32 = 2;
pub const MULTIBOOT_TAG_TYPE_MODULE: u32 = 3;
pub const MULTIBOOT_TAG_TYPE_BASIC_MEMINFO: u32 = 4;
pub const MULTIBOOT_TAG_TYPE_BOOTDEV: u32 = 5;
pub const MULTIBOOT_TAG_TYPE_MMAP: u32 = 6;
pub const MULTIBOOT_TAG_TYPE_VBE: u32 = 7;
pub const MULTIBOOT_TAG_TYPE_FRAMEBUFFER: u32 = 8;
pub const MULTIBOOT_TAG_TYPE_ELF_SECTIONS: u32 = 9;
pub const MULTIBOOT_TAG_TYPE_APM: u32 = 10;
pub const MULTIBOOT_TAG_TYPE_EFI32: u32 = 11;
pub const MULTIBOOT_TAG_TYPE_EFI64: u32 = 12;
pub const MULTIBOOT_TAG_TYPE_SMBIOS: u32 = 13;
pub const MULTIBOOT_TAG_TYPE_ACPI_OLD: u32 = 14;
pub const MULTIBOOT_TAG_TYPE_ACPI_NEW: u32 = 15;
pub const MULTIBOOT_TAG_TYPE_NETWORK: u32 = 16;
pub const MULTIBOOT_TAG_TYPE_EFI_MEM_MAP: u32 = 17;
pub const MULTIBOOT_TAG_TYPE_EFI_BOOT_SERV: u32 = 18;
pub const MULTIBOOT_TAG_TYPE_EFI_32B_HANDLE: u32 = 19;
pub const MULTIBOOT_TAG_TYPE_EFI_64B_HANDLE: u32 = 20;
pub const MULTIBOOT_TAG_TYPE_IMAGE_BASE: u32 = 21;
pub const MULTIBOOT_TAG_TYPE_HRT: u32 = 4027445261;
pub const MULTIBOOT_HEADER_TAG_END: u32 = 0;
pub const MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST: u32 = 1;
pub const MULTIBOOT_HEADER_TAG_ADDRESS: u32 = 2;
pub const MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS: u32 = 3;
pub const MULTIBOOT_HEADER_TAG_CONSOLE_FLAGS: u32 = 4;
pub const MULTIBOOT_HEADER_TAG_FRAMEBUFFER: u32 = 5;
pub const MULTIBOOT_HEADER_TAG_MODULE_ALIGN: u32 = 6;
pub const MULTIBOOT_ARCHITECTURE_I386: u32 = 0;
pub const MULTIBOOT_ARCHITECTURE_MIPS32: u32 = 4;
pub const MULTIBOOT_HEADER_TAG_OPTIONAL: u32 = 1;
pub const MULTIBOOT_CONSOLE_FLAGS_CONSOLE_REQUIRED: u32 = 1;
pub const MULTIBOOT_CONSOLE_FLAGS_EGA_TEXT_SUPPORTED: u32 = 2;
pub const MULTIBOOT_MEMORY_AVAILABLE: u32 = 1;
pub const MULTIBOOT_MEMORY_RESERVED: u32 = 2;
pub const MULTIBOOT_MEMORY_ACPI_RECLAIMABLE: u32 = 3;
pub const MULTIBOOT_MEMORY_NVS: u32 = 4;
pub const MULTIBOOT_MEMORY_BADRAM: u32 = 5;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_INDEXED: u32 = 0;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_RGB: u32 = 1;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT: u32 = 2;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type schar_t = ::libc::c_schar;
pub type uchar_t = ::libc::c_uchar;
pub type sshort_t = ::libc::c_short;
pub type ushort_t = ::libc::c_ushort;
pub type sint_t = ::libc::c_int;
pub type uint_t = ::libc::c_uint;
pub type sllong_t = ::libc::c_longlong;
pub type ullong_t = ::libc::c_ulonglong;
pub type slong_t = ::libc::c_long;
pub type ulong_t = ::libc::c_ulong;
pub type off_t = ::libc::c_ulong;
pub type sint64_t = ::libc::c_long;
pub type sint32_t = ::libc::c_int;
pub type sint16_t = ::libc::c_short;
pub type sint8_t = ::libc::c_char;
pub type addr_t = ulong_t;
pub type bool_t = uchar_t;
extern "C" {
    #[link_name = "\u{1}_ctype"]
    pub static mut _ctype: [::libc::c_uchar; 0usize];
}
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn atoi(buf: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strtoi(nptr: *const ::libc::c_char, endptr: *mut *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strtol(
        str: *const ::libc::c_char,
        endptr: *mut *mut ::libc::c_char,
        base: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn atol(nptr: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn atox(buf: *const ::libc::c_char) -> u64;
}
extern "C" {
    pub fn strtox(nptr: *const ::libc::c_char, endptr: *mut *mut ::libc::c_char) -> u64;
}
extern "C" {
    pub fn str_toupper(s: *mut ::libc::c_char);
}
extern "C" {
    pub fn str_tolower(s: *mut ::libc::c_char);
}
extern "C" {
    pub fn ultoa(
        x: ::libc::c_ulong,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ltoa(
        x: ::libc::c_long,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn utoa(
        x: ::libc::c_uint,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn itoa(
        x: ::libc::c_int,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ustoa(
        x: ::libc::c_ushort,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn stoa(
        x: ::libc::c_short,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn uctoa(
        x: ::libc::c_uchar,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ctoa(
        x: ::libc::c_char,
        buf: *mut ::libc::c_char,
        numdigits: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn dtoa_r(
        x: f64,
        mode: ::libc::c_int,
        ndigits: ::libc::c_int,
        decpt: *mut ::libc::c_int,
        sign: *mut ::libc::c_int,
        rve: *mut *mut ::libc::c_char,
        buf: *mut ::libc::c_char,
        blen: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn dtoa_printf_helper(
        x: f64,
        pf_mode: ::libc::c_char,
        ndigits: ::libc::c_int,
        prec: ::libc::c_int,
        buf: *mut ::libc::c_char,
        blen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strtod(s: *const ::libc::c_char, se: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn strtok(s: *mut ::libc::c_char, delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::core::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::core::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gdt_desc64 {
    pub limit: u16,
    pub base: u64,
}
#[test]
fn bindgen_test_layout_gdt_desc64() {
    assert_eq!(
        ::core::mem::size_of::<gdt_desc64>(),
        10usize,
        concat!("Size of: ", stringify!(gdt_desc64))
    );
    assert_eq!(
        ::core::mem::align_of::<gdt_desc64>(),
        1usize,
        concat!("Alignment of ", stringify!(gdt_desc64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc64>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc64),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc64>())).base as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc64),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gdt_desc32 {
    pub limit: u16,
    pub base: u32,
}
#[test]
fn bindgen_test_layout_gdt_desc32() {
    assert_eq!(
        ::core::mem::size_of::<gdt_desc32>(),
        6usize,
        concat!("Size of: ", stringify!(gdt_desc32))
    );
    assert_eq!(
        ::core::mem::align_of::<gdt_desc32>(),
        1usize,
        concat!("Alignment of ", stringify!(gdt_desc32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc32>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc32),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gdt_desc32>())).base as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gdt_desc32),
            "::",
            stringify!(base)
        )
    );
}
pub const gate_type_t_GATE_TYPE_INT: gate_type_t = 14;
pub const gate_type_t_GATE_TYPE_TRAP: gate_type_t = 15;
pub const gate_type_t_GATE_TYPE_CALL: gate_type_t = 12;
pub const gate_type_t_GATE_TYPE_TASK: gate_type_t = 5;
pub type gate_type_t = u32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct excp_entry_state {
    pub error_code: ulong_t,
    pub rip: ulong_t,
    pub cs: ulong_t,
    pub rflags: ulong_t,
    pub rsp: ulong_t,
    pub ss: ulong_t,
}
#[test]
fn bindgen_test_layout_excp_entry_state() {
    assert_eq!(
        ::core::mem::size_of::<excp_entry_state>(),
        48usize,
        concat!("Size of: ", stringify!(excp_entry_state))
    );
    assert_eq!(
        ::core::mem::align_of::<excp_entry_state>(),
        1usize,
        concat!("Alignment of ", stringify!(excp_entry_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).error_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).cs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rflags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).rsp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<excp_entry_state>())).ss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(excp_entry_state),
            "::",
            stringify!(ss)
        )
    );
}
pub type excp_entry_t = excp_entry_state;
pub type excp_vec_t = ulong_t;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct gate_desc64 {
    pub __bindgen_anon_1: gate_desc64__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union gate_desc64__bindgen_ty_1 {
    pub __bindgen_anon_1: gate_desc64__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: gate_desc64__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gate_desc64__bindgen_ty_1__bindgen_ty_1 {
    pub val_lo: u64,
    pub val_hi: u64,
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_1>())).val_lo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val_lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_1>())).val_hi as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val_hi)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gate_desc64__bindgen_ty_1__bindgen_ty_2 {
    pub target_off_lo: u16,
    pub target_css: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub target_off_mid: u16,
    pub target_off_hi: u32,
    pub rsvd2: u32,
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_lo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_css
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_css)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_mid
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).target_off_hi
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_off_hi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gate_desc64__bindgen_ty_1__bindgen_ty_2>())).rsvd2 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_desc64__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rsvd2)
        )
    );
}
impl gate_desc64__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn ist(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ist: u8,
        rsvd0: u8,
        type_: u8,
        rsvd1: u8,
        dpl: u8,
        p: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ist: u8 = unsafe { ::core::mem::transmute(ist) };
            ist as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let rsvd0: u8 = unsafe { ::core::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rsvd1: u8 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u8 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u8 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gate_desc64__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(gate_desc64__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_desc64__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_gate_desc64() {
    assert_eq!(
        ::core::mem::size_of::<gate_desc64>(),
        16usize,
        concat!("Size of: ", stringify!(gate_desc64))
    );
    assert_eq!(
        ::core::mem::align_of::<gate_desc64>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_desc64))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct idt_desc {
    pub size: u16,
    pub base_addr: u64,
}
#[test]
fn bindgen_test_layout_idt_desc() {
    assert_eq!(
        ::core::mem::size_of::<idt_desc>(),
        10usize,
        concat!("Size of: ", stringify!(idt_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<idt_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(idt_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idt_desc>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idt_desc>())).base_addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_desc),
            "::",
            stringify!(base_addr)
        )
    );
}
extern "C" {
    pub fn setup_idt() -> ::libc::c_int;
}
extern "C" {
    pub fn idt_assign_entry(
        entry: ulong_t,
        handler_addr: ulong_t,
        state_addr: ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn idt_get_entry(
        entry: ulong_t,
        handler_addr: *mut ulong_t,
        state_addr: *mut ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn idt_find_and_reserve_range(
        numentries: ulong_t,
        aligned: ::libc::c_int,
        first: *mut ulong_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn null_excp_handler(
        excp: *mut excp_entry_t,
        vec: excp_vec_t,
        fault_addr: addr_t,
        state_addr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn null_irq_handler(
        excp: *mut excp_entry_t,
        vector: excp_vec_t,
        state_addr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn panic(fmt: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn printk(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vprintk(fmt: *const ::libc::c_char, args: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn early_printk(fmt: *const ::libc::c_char, args: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn simple_strtoul(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn simple_strtol(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn simple_strtoull(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(
        arg1: *const ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_longlong;
}
extern "C" {
    pub fn strict_strtoul(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strict_strtol(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_long,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strict_strtoull(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_ulonglong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strict_strtoll(
        cp: *const ::libc::c_char,
        base: ::libc::c_uint,
        res: *mut ::libc::c_longlong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut ::libc::c_char,
        size: ::libc::c_ulong,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vscnprintf(
        buf: *mut ::libc::c_char,
        size: usize,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut ::libc::c_char,
        size: ::libc::c_ulong,
        fmt: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn scnprintf(
        buf: *mut ::libc::c_char,
        size: usize,
        fmt: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut ::libc::c_char,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::libc::c_char, fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        buf: *const ::libc::c_char,
        fmt: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sscanf(buf: *const ::libc::c_char, fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn warn_slowpath(
        file: *const ::libc::c_char,
        line: ::libc::c_int,
        fmt: *const ::libc::c_char,
        ...
    );
}
extern "C" {
    pub fn msr_write(msr: u32, data: u64);
}
extern "C" {
    pub fn msr_read(msr: u32) -> u64;
}
extern "C" {
    #[doc = " EXTERNAL INTERFACE"]
    pub fn nk_get_num_cpus() -> u32;
}
extern "C" {
    pub fn nk_get_cpu_by_lapicid(lapicid: u8) -> u8;
}
pub const apic_mode_t_APIC_INVALID: apic_mode_t = 0;
pub const apic_mode_t_APIC_DISABLED: apic_mode_t = 1;
pub const apic_mode_t_APIC_XAPIC: apic_mode_t = 2;
pub const apic_mode_t_APIC_X2APIC: apic_mode_t = 3;
pub type apic_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apic_dev {
    pub mode: apic_mode_t,
    pub base_addr: ulong_t,
    pub version: u8,
    pub id: uint_t,
    pub spur_int_cnt: u64,
    pub err_int_cnt: u64,
    pub bus_freq_hz: u64,
    pub ps_per_tick: u64,
    pub cycles_per_us: u64,
    pub cycles_per_tick: u64,
    pub timer_set: u8,
    pub current_ticks: u32,
    pub timer_count: u64,
    pub in_timer_interrupt: ::libc::c_int,
    pub in_kick_interrupt: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_apic_dev() {
    assert_eq!(
        ::core::mem::size_of::<apic_dev>(),
        96usize,
        concat!("Size of: ", stringify!(apic_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<apic_dev>(),
        8usize,
        concat!("Alignment of ", stringify!(apic_dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).base_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).spur_int_cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(spur_int_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).err_int_cnt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(err_int_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).bus_freq_hz as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(bus_freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).ps_per_tick as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(ps_per_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).cycles_per_us as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(cycles_per_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).cycles_per_tick as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(cycles_per_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).timer_set as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(timer_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).current_ticks as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(current_ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).timer_count as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(timer_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).in_timer_interrupt as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(in_timer_interrupt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apic_dev>())).in_kick_interrupt as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_dev),
            "::",
            stringify!(in_kick_interrupt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct naut_info {
    _unused: [u8; 0],
}
extern "C" {
    pub fn apic_get_id(apic: *mut apic_dev) -> u32;
}
extern "C" {
    pub fn apic_do_eoi();
}
extern "C" {
    pub fn apic_self_ipi(apic: *mut apic_dev, vector: uint_t);
}
extern "C" {
    pub fn apic_send_iipi(apic: *mut apic_dev, remote_id: u32);
}
extern "C" {
    pub fn apic_deinit_iipi(apic: *mut apic_dev, remote_id: u32);
}
extern "C" {
    pub fn apic_send_sipi(apic: *mut apic_dev, remote_id: u32, target: u8);
}
extern "C" {
    pub fn apic_bcast_iipi(apic: *mut apic_dev);
}
extern "C" {
    pub fn apic_bcast_deinit_iipi(apic: *mut apic_dev);
}
extern "C" {
    pub fn apic_bcast_sipi(apic: *mut apic_dev, target: u8);
}
extern "C" {
    pub fn apic_init(core: *mut cpu);
}
extern "C" {
    pub fn apic_get_maxlvt(apic: *mut apic_dev) -> ::libc::c_int;
}
extern "C" {
    pub fn apic_read_timer(apic: *mut apic_dev) -> ::libc::c_int;
}
extern "C" {
    pub fn apic_wait_for_send(apic: *mut apic_dev) -> u32;
}
extern "C" {
    pub fn apic_cycles_to_ticks(apic: *mut apic_dev, cycles: u64) -> u32;
}
extern "C" {
    pub fn apic_realtime_to_ticks(apic: *mut apic_dev, ns: u64) -> u32;
}
extern "C" {
    pub fn apic_realtime_to_cycles(apic: *mut apic_dev, ns: u64) -> u64;
}
extern "C" {
    pub fn apic_cycles_to_realtime(apic: *mut apic_dev, cycles: u64) -> u64;
}
extern "C" {
    pub fn apic_set_oneshot_timer(apic: *mut apic_dev, ticks: u32);
}
pub const nk_timer_condition_t_UNCOND: nk_timer_condition_t = 0;
pub const nk_timer_condition_t_IF_EARLIER: nk_timer_condition_t = 1;
pub const nk_timer_condition_t_IF_LATER: nk_timer_condition_t = 2;
pub type nk_timer_condition_t = u32;
extern "C" {
    pub fn apic_update_oneshot_timer(apic: *mut apic_dev, ticks: u32, cond: nk_timer_condition_t);
}
extern "C" {
    pub fn nk_detect_cpu_freq(arg1: u32) -> ulong_t;
}
extern "C" {
    pub fn nk_is_amd() -> u8;
}
extern "C" {
    pub fn nk_is_intel() -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_regs {
    pub r15: ulong_t,
    pub r14: ulong_t,
    pub r13: ulong_t,
    pub r12: ulong_t,
    pub r11: ulong_t,
    pub r10: ulong_t,
    pub r9: ulong_t,
    pub r8: ulong_t,
    pub rbp: ulong_t,
    pub rdi: ulong_t,
    pub rsi: ulong_t,
    pub rdx: ulong_t,
    pub rcx: ulong_t,
    pub rbx: ulong_t,
    pub rax: ulong_t,
    pub vector: ulong_t,
    pub err_code: ulong_t,
    pub rip: ulong_t,
    pub cs: ulong_t,
    pub rflags: ulong_t,
    pub rsp: ulong_t,
    pub ss: ulong_t,
}
#[test]
fn bindgen_test_layout_nk_regs() {
    assert_eq!(
        ::core::mem::size_of::<nk_regs>(),
        176usize,
        concat!("Size of: ", stringify!(nk_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_regs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r11 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r10 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r9 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).r8 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rbp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rdi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rsi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rdx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rcx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rbx as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rax as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).vector as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).err_code as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rip as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rflags as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).rsp as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_regs>())).ss as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_hashtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_malloc_data() {
    assert_eq!(
        ::core::mem::size_of::<malloc_data>(),
        40usize,
        concat!("Size of: ", stringify!(malloc_data))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_data>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_free_data() {
    assert_eq!(
        ::core::mem::size_of::<free_data>(),
        40usize,
        concat!("Size of: ", stringify!(free_data))
    );
    assert_eq!(
        ::core::mem::align_of::<free_data>(),
        8usize,
        concat!("Alignment of ", stringify!(free_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(free_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_irq_data() {
    assert_eq!(
        ::core::mem::size_of::<irq_data>(),
        40usize,
        concat!("Size of: ", stringify!(irq_data))
    );
    assert_eq!(
        ::core::mem::align_of::<irq_data>(),
        8usize,
        concat!("Alignment of ", stringify!(irq_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<irq_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_switch_data {
    pub count: u64,
    pub start_count: u64,
    pub avg_latency: u64,
    pub max_latency: u64,
    pub min_latency: u64,
}
#[test]
fn bindgen_test_layout_thread_switch_data() {
    assert_eq!(
        ::core::mem::size_of::<thread_switch_data>(),
        40usize,
        concat!("Size of: ", stringify!(thread_switch_data))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_switch_data>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_switch_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).start_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(start_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).avg_latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(avg_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).max_latency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_switch_data>())).min_latency as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_switch_data),
            "::",
            stringify!(min_latency)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_instr_data {
    pub func_htable: *mut nk_hashtable,
    pub irqstat: irq_data,
    pub mallocstat: malloc_data,
    pub freestat: free_data,
    pub thr_switch: thread_switch_data,
}
#[test]
fn bindgen_test_layout_nk_instr_data() {
    assert_eq!(
        ::core::mem::size_of::<nk_instr_data>(),
        168usize,
        concat!("Size of: ", stringify!(nk_instr_data))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_instr_data>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_instr_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).func_htable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(func_htable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).irqstat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(irqstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).mallocstat as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(mallocstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).freestat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(freestat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_instr_data>())).thr_switch as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_instr_data),
            "::",
            stringify!(thr_switch)
        )
    );
}
extern "C" {
    pub fn nk_profile_func_enter(func: *const ::libc::c_char);
}
extern "C" {
    pub fn nk_profile_func_exit(func: *const ::libc::c_char);
}
extern "C" {
    pub fn nk_thr_switch_prof_enter();
}
extern "C" {
    pub fn nk_thr_switch_prof_exit();
}
extern "C" {
    pub fn nk_irq_prof_enter();
}
extern "C" {
    pub fn nk_irq_prof_exit();
}
extern "C" {
    pub fn nk_malloc_enter();
}
extern "C" {
    pub fn nk_malloc_exit();
}
extern "C" {
    pub fn nk_free_enter();
}
extern "C" {
    pub fn nk_free_exit();
}
extern "C" {
    pub fn nk_instrument_init();
}
extern "C" {
    pub fn nk_instrument_start();
}
extern "C" {
    pub fn nk_instrument_end();
}
extern "C" {
    pub fn nk_instrument_query();
}
extern "C" {
    pub fn nk_instrument_clear();
}
extern "C" {
    pub fn nk_instrument_calibrate(loops: ::libc::c_uint);
}
pub type spinlock_t = u32;
extern "C" {
    pub fn spinlock_init(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spinlock_deinit(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_nopause(lock: *mut spinlock_t);
}
extern "C" {
    pub fn spin_lock_irq_save_nopause(lock: *mut spinlock_t) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buddy_mempool {
    pub base_addr: ulong_t,
    #[doc = " base address of the memory pool"]
    pub pool_order: ulong_t,
    #[doc = " size of memory pool = 2^pool_order"]
    pub min_order: ulong_t,
    #[doc = " minimum allocatable block size"]
    pub num_blocks: ulong_t,
    #[doc = " number of bits in tag_bits"]
    pub tag_bits: *mut ulong_t,
    #[doc = " one bit for each 2^min_order block"]
    #[doc = "   0 = block is allocated"]
    #[doc = "   1 = block is available"]
    pub avail: *mut list_head,
    #[doc = " one free list for each block size,"]
    #[doc = " indexed by block order:"]
    #[doc = "   avail[i] = free list of 2^i blocks"]
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_buddy_mempool() {
    assert_eq!(
        ::core::mem::size_of::<buddy_mempool>(),
        56usize,
        concat!("Size of: ", stringify!(buddy_mempool))
    );
    assert_eq!(
        ::core::mem::align_of::<buddy_mempool>(),
        8usize,
        concat!("Alignment of ", stringify!(buddy_mempool))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).base_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).pool_order as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(pool_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).min_order as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(min_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).num_blocks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).tag_bits as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(tag_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).avail as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_mempool>())).lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_mempool),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    pub fn buddy_init(
        base_addr: ulong_t,
        pool_order: ulong_t,
        min_order: ulong_t,
    ) -> *mut buddy_mempool;
}
extern "C" {
    pub fn buddy_free(mp: *mut buddy_mempool, addr: *mut ::libc::c_void, order: ulong_t);
}
extern "C" {
    pub fn buddy_alloc(mp: *mut buddy_mempool, order: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn buddy_sanity_check(mp: *mut buddy_mempool) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buddy_pool_stats {
    pub start_addr: *mut ::libc::c_void,
    pub end_addr: *mut ::libc::c_void,
    pub total_blocks_free: u64,
    pub total_bytes_free: u64,
    pub min_alloc_size: u64,
    pub max_alloc_size: u64,
}
#[test]
fn bindgen_test_layout_buddy_pool_stats() {
    assert_eq!(
        ::core::mem::size_of::<buddy_pool_stats>(),
        48usize,
        concat!("Size of: ", stringify!(buddy_pool_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<buddy_pool_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(buddy_pool_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_pool_stats>())).start_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(start_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<buddy_pool_stats>())).end_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(end_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).total_blocks_free as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(total_blocks_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).total_bytes_free as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(total_bytes_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).min_alloc_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(min_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<buddy_pool_stats>())).max_alloc_size as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(buddy_pool_stats),
            "::",
            stringify!(max_alloc_size)
        )
    );
}
extern "C" {
    pub fn buddy_stats(mp: *mut buddy_mempool, stats: *mut buddy_pool_stats);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_map_entry {
    pub addr: u64,
    pub len: u64,
    pub type_: u32,
}
#[test]
fn bindgen_test_layout_mem_map_entry() {
    assert_eq!(
        ::core::mem::size_of::<mem_map_entry>(),
        24usize,
        concat!("Size of: ", stringify!(mem_map_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_map_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_map_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_map_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_map_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_map_entry>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_map_entry),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_map_entry>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_map_entry),
            "::",
            stringify!(type_)
        )
    );
}
pub type mem_map_entry_t = mem_map_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmap_info {
    pub usable_ram: u64,
    pub total_mem: u64,
    pub last_pfn: u32,
    pub num_regions: u32,
}
#[test]
fn bindgen_test_layout_mmap_info() {
    assert_eq!(
        ::core::mem::size_of::<mmap_info>(),
        24usize,
        concat!("Size of: ", stringify!(mmap_info))
    );
    assert_eq!(
        ::core::mem::align_of::<mmap_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mmap_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).usable_ram as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(usable_ram)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).total_mem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(total_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).last_pfn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(last_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mmap_info>())).num_regions as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mmap_info),
            "::",
            stringify!(num_regions)
        )
    );
}
pub type mmap_info_t = mmap_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct boot_mem_info {
    pub page_map: *mut ulong_t,
    pub npages: ulong_t,
    pub pm_len: ulong_t,
    pub last_offset: ulong_t,
    pub last_pos: ulong_t,
    pub last_success: ulong_t,
}
#[test]
fn bindgen_test_layout_boot_mem_info() {
    assert_eq!(
        ::core::mem::size_of::<boot_mem_info>(),
        48usize,
        concat!("Size of: ", stringify!(boot_mem_info))
    );
    assert_eq!(
        ::core::mem::align_of::<boot_mem_info>(),
        8usize,
        concat!("Alignment of ", stringify!(boot_mem_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).page_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(page_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).npages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).pm_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(pm_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).last_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(last_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).last_pos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(last_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<boot_mem_info>())).last_success as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_mem_info),
            "::",
            stringify!(last_success)
        )
    );
}
pub type boot_mem_info_t = boot_mem_info;
extern "C" {
    pub fn mm_boot_get_region(i: ::libc::c_uint) -> *mut mem_map_entry;
}
extern "C" {
    pub fn mm_boot_num_regions() -> ::libc::c_uint;
}
extern "C" {
    pub fn mm_get_usable_ram() -> u64;
}
extern "C" {
    pub fn mm_get_all_mem() -> u64;
}
extern "C" {
    pub fn mm_boot_last_pfn() -> ulong_t;
}
extern "C" {
    pub fn mm_boot_init(mbd: ulong_t) -> ::libc::c_int;
}
extern "C" {
    pub fn mm_boot_kmem_init();
}
extern "C" {
    pub fn mm_boot_kmem_cleanup();
}
extern "C" {
    pub fn mm_dump_page_map();
}
extern "C" {
    pub fn mm_boot_reserve_mem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn mm_boot_reserve_vmem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn mm_boot_free_mem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn mm_boot_free_vmem(start: addr_t, size: ulong_t);
}
extern "C" {
    pub fn __mm_boot_alloc(size: ulong_t, align: ulong_t, goal: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mm_boot_alloc(size: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mm_boot_alloc_aligned(size: ulong_t, align: ulong_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mm_boot_free(addr: *mut ::libc::c_void, size: ulong_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_data {
    pub ordered_regions: list_head,
}
#[test]
fn bindgen_test_layout_kmem_data() {
    assert_eq!(
        ::core::mem::size_of::<kmem_data>(),
        16usize,
        concat!("Size of: ", stringify!(kmem_data))
    );
    assert_eq!(
        ::core::mem::align_of::<kmem_data>(),
        8usize,
        concat!("Alignment of ", stringify!(kmem_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_data>())).ordered_regions as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_data),
            "::",
            stringify!(ordered_regions)
        )
    );
}
extern "C" {
    pub fn nk_kmem_init() -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_region {
    _unused: [u8; 0],
}
extern "C" {
    pub fn kmem_get_base_zone() -> *mut mem_region;
}
extern "C" {
    pub fn kmem_get_region_by_addr(addr: ulong_t) -> *mut mem_region;
}
extern "C" {
    pub fn kmem_add_memory(mem: *mut mem_region, base_addr: ulong_t, size: usize);
}
extern "C" {
    pub fn kmem_inform_boot_allocation(low: *mut ::libc::c_void, high: *mut ::libc::c_void);
}
extern "C" {
    pub fn kmem_malloc_specific(
        size: usize,
        cpu: ::libc::c_int,
        zero: ::libc::c_int,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_malloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_mallocz(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_realloc(ptr: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn kmem_free(addr: *mut ::libc::c_void);
}
extern "C" {
    pub fn kmem_find_block(
        any_addr: *mut ::libc::c_void,
        block_addr: *mut *mut ::libc::c_void,
        block_size: *mut u64,
        flags: *mut u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_set_block_flags(block_addr: *mut ::libc::c_void, flags: u64) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_mask_all_blocks_flags(mask: u64, ormask: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_get_internal_pointer_range(
        start: *mut *mut ::libc::c_void,
        end: *mut *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn kmem_apply_to_matching_blocks(
        mask: u64,
        flags: u64,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                block: *mut ::libc::c_void,
                state: *mut ::libc::c_void,
            ) -> ::libc::c_int,
        >,
        state: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kmem_sanity_check() -> ::libc::c_int;
}
extern "C" {
    pub fn arch_detect_mem_map(
        mm_info: *mut mmap_info_t,
        memory_map: *mut mem_map_entry_t,
        mbd: ::libc::c_ulong,
    );
}
extern "C" {
    pub fn arch_reserve_boot_regions(mbd: ::libc::c_ulong);
}
#[repr(C)]
#[derive(Debug)]
pub struct kmem_stats {
    pub total_num_pools: u64,
    pub total_blocks_free: u64,
    pub total_bytes_free: u64,
    pub min_alloc_size: u64,
    pub max_alloc_size: u64,
    pub max_pools: u64,
    pub num_pools: u64,
    pub pool_stats: __IncompleteArrayField<buddy_pool_stats>,
}
#[test]
fn bindgen_test_layout_kmem_stats() {
    assert_eq!(
        ::core::mem::size_of::<kmem_stats>(),
        56usize,
        concat!("Size of: ", stringify!(kmem_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<kmem_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(kmem_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).total_num_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(total_num_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).total_blocks_free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(total_blocks_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).total_bytes_free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(total_bytes_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).min_alloc_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(min_alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).max_alloc_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(max_alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).max_pools as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(max_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).num_pools as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(num_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kmem_stats>())).pool_stats as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kmem_stats),
            "::",
            stringify!(pool_stats)
        )
    );
}
extern "C" {
    pub fn kmem_num_pools() -> u64;
}
extern "C" {
    pub fn kmem_stats(stats: *mut kmem_stats);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_queue {
    pub queue: list_head,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_nk_queue() {
    assert_eq!(
        ::core::mem::size_of::<nk_queue>(),
        24usize,
        concat!("Size of: ", stringify!(nk_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_queue>())).queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_queue),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_queue>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_queue),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_queue_entry {
    pub node: list_head,
}
#[test]
fn bindgen_test_layout_nk_queue_entry() {
    assert_eq!(
        ::core::mem::size_of::<nk_queue_entry>(),
        16usize,
        concat!("Size of: ", stringify!(nk_queue_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_queue_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_queue_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_queue_entry>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_queue_entry),
            "::",
            stringify!(node)
        )
    );
}
pub type nk_queue_t = nk_queue;
pub type nk_queue_entry_t = nk_queue_entry;
extern "C" {
    pub fn nk_queue_create() -> *mut nk_queue_t;
}
extern "C" {
    pub fn nk_queue_destroy(q: *mut nk_queue_t, free_entries: u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_topo_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_cpu_coords {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_thread {
    _unused: [u8; 0],
}
pub type nk_xcall_func_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void)>;
pub type cpu_id_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_xcall {
    pub xcall_node: nk_queue_entry_t,
    pub data: *mut ::libc::c_void,
    pub fun: nk_xcall_func_t,
    pub xcall_done: u8,
    pub has_waiter: u8,
}
#[test]
fn bindgen_test_layout_nk_xcall() {
    assert_eq!(
        ::core::mem::size_of::<nk_xcall>(),
        40usize,
        concat!("Size of: ", stringify!(nk_xcall))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_xcall>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_xcall))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).xcall_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(xcall_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).fun as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(fun)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).xcall_done as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(xcall_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_xcall>())).has_waiter as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_xcall),
            "::",
            stringify!(has_waiter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu {
    pub cur_thread: *mut nk_thread,
    pub interrupt_nesting_level: u16,
    pub preempt_disable_level: u16,
    pub interrupt_count: u64,
    pub exception_count: u64,
    pub id: cpu_id_t,
    pub lapic_id: u32,
    pub enabled: u8,
    pub is_bsp: u8,
    pub cpu_sig: u32,
    pub feat_flags: u32,
    pub booted: u8,
    pub apic: *mut apic_dev,
    pub system: *mut sys_info,
    pub lock: spinlock_t,
    pub sched_state: *mut nk_sched_percpu_state,
    pub xcall_q: *mut nk_queue_t,
    pub xcall_nowait_info: nk_xcall,
    pub cpu_khz: ulong_t,
    pub tp: *mut nk_topo_params,
    pub coord: *mut nk_cpu_coords,
    pub domain: *mut numa_domain,
    pub kmem: kmem_data,
    pub rand: *mut nk_rand_info,
}
#[test]
fn bindgen_test_layout_cpu() {
    assert_eq!(
        ::core::mem::size_of::<cpu>(),
        192usize,
        concat!("Size of: ", stringify!(cpu))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).cur_thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(cur_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).interrupt_nesting_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(interrupt_nesting_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).preempt_disable_level as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(preempt_disable_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).interrupt_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(interrupt_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).exception_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(exception_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).id as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).lapic_id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(lapic_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).enabled as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).is_bsp as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(is_bsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).cpu_sig as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(cpu_sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).feat_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(feat_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).booted as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(booted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).apic as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(apic))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).system as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(system)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).lock as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(lock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).sched_state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(sched_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).xcall_q as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(xcall_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).xcall_nowait_info as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(xcall_nowait_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).cpu_khz as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(cpu_khz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).tp as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(tp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).coord as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(coord)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).domain as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).kmem as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(kmem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu>())).rand as *const _ as usize },
        184usize,
        concat!("Offset of field: ", stringify!(cpu), "::", stringify!(rand))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ap_init_area {
    pub stack: u32,
    pub rsvd: u32,
    pub gdt: [u32; 6usize],
    pub gdt_limit: u16,
    pub gdt_base: u32,
    pub rsvd1: u16,
    pub gdt64: [u64; 3usize],
    pub gdt64_limit: u16,
    pub gdt64_base: u64,
    pub cr3: u64,
    pub cpu_ptr: *mut cpu,
    pub entry: ::core::option::Option<unsafe extern "C" fn(core: *mut cpu)>,
}
#[test]
fn bindgen_test_layout_ap_init_area() {
    assert_eq!(
        ::core::mem::size_of::<ap_init_area>(),
        98usize,
        concat!("Size of: ", stringify!(ap_init_area))
    );
    assert_eq!(
        ::core::mem::align_of::<ap_init_area>(),
        1usize,
        concat!("Alignment of ", stringify!(ap_init_area))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).rsvd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt_limit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt_base as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).rsvd1 as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(rsvd1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt64 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt64_limit as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt64_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).gdt64_base as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(gdt64_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).cr3 as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).cpu_ptr as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(cpu_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ap_init_area>())).entry as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_init_area),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    pub fn smp_early_init(naut: *mut naut_info) -> ::libc::c_int;
}
extern "C" {
    pub fn smp_bringup_aps(naut: *mut naut_info) -> ::libc::c_int;
}
extern "C" {
    pub fn smp_xcall(
        cpu_id: cpu_id_t,
        fun: nk_xcall_func_t,
        arg: *mut ::libc::c_void,
        wait: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn smp_ap_entry(core: *mut cpu);
}
extern "C" {
    pub fn smp_setup_xcall_bsp(core: *mut cpu) -> ::libc::c_int;
}
extern "C" {
    pub fn arch_early_init(naut: *mut naut_info) -> ::libc::c_int;
}
pub type pml4e_t = ulong_t;
pub type pdpte_t = ulong_t;
pub type pde_t = ulong_t;
pub type pte_t = ulong_t;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct nk_pf_error {
    pub __bindgen_anon_1: nk_pf_error__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nk_pf_error__bindgen_ty_1 {
    pub val: u32,
    pub __bindgen_anon_1: nk_pf_error__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct nk_pf_error__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_nk_pf_error__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nk_pf_error__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(nk_pf_error__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nk_pf_error__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nk_pf_error__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl nk_pf_error__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn p(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_usr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd_bit(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd_bit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ifetch(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ifetch(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        p: u8,
        wr: u8,
        usr: u8,
        rsvd_bit: u8,
        ifetch: u8,
        rsvd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let p: u8 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wr: u8 = unsafe { ::core::mem::transmute(wr) };
            wr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let usr: u8 = unsafe { ::core::mem::transmute(usr) };
            usr as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rsvd_bit: u8 = unsafe { ::core::mem::transmute(rsvd_bit) };
            rsvd_bit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ifetch: u8 = unsafe { ::core::mem::transmute(ifetch) };
            ifetch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let rsvd: u32 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_nk_pf_error__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nk_pf_error__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(nk_pf_error__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_pf_error__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(nk_pf_error__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_pf_error__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_pf_error__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_nk_pf_error() {
    assert_eq!(
        ::core::mem::size_of::<nk_pf_error>(),
        4usize,
        concat!("Size of: ", stringify!(nk_pf_error))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_pf_error>(),
        1usize,
        concat!("Alignment of ", stringify!(nk_pf_error))
    );
}
pub type nk_pf_err_t = nk_pf_error;
pub const mem_zone_type_t_MEM_USABLE: mem_zone_type_t = 0;
pub const mem_zone_type_t_MEM_UNUSABLE: mem_zone_type_t = 1;
pub type mem_zone_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_mem_zone {
    pub type_: mem_zone_type_t,
    pub start: u64,
    pub length: u64,
    pub attrs: u64,
    pub node: list_head,
}
#[test]
fn bindgen_test_layout_nk_mem_zone() {
    assert_eq!(
        ::core::mem::size_of::<nk_mem_zone>(),
        48usize,
        concat!("Size of: ", stringify!(nk_mem_zone))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_mem_zone>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_mem_zone))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).attrs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_zone>())).node as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_zone),
            "::",
            stringify!(node)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_mem_info {
    pub page_map: *mut ulong_t,
    pub pm_start: addr_t,
    pub pm_end: addr_t,
    pub phys_mem_avail: ulong_t,
    pub npages: ulong_t,
    pub mem_zone_list: list_head,
}
#[test]
fn bindgen_test_layout_nk_mem_info() {
    assert_eq!(
        ::core::mem::size_of::<nk_mem_info>(),
        56usize,
        concat!("Size of: ", stringify!(nk_mem_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nk_mem_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nk_mem_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).page_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(page_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).pm_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(pm_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).pm_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(pm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).phys_mem_avail as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(phys_mem_avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).npages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nk_mem_info>())).mem_zone_list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nk_mem_info),
            "::",
            stringify!(mem_zone_list)
        )
    );
}
pub const page_size_t_PS_4K: page_size_t = 0;
pub const page_size_t_PS_2M: page_size_t = 1;
pub const page_size_t_PS_1G: page_size_t = 2;
pub type page_size_t = u32;
extern "C" {
    pub fn nk_map_page(vaddr: addr_t, paddr: addr_t, flags: u64, ps: page_size_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_map_page_nocache(paddr: addr_t, flags: u64, ps: page_size_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nk_paging_init(mem: *mut nk_mem_info, mbd: ulong_t);
}
extern "C" {
    pub fn nk_pf_handler(
        excp: *mut excp_entry_t,
        vector: excp_vec_t,
        fault_addr: addr_t,
    ) -> ::libc::c_int;
}
pub type multiboot_uint8_t = ::libc::c_uchar;
pub type multiboot_uint16_t = ::libc::c_ushort;
pub type multiboot_uint32_t = ::libc::c_uint;
pub type multiboot_uint64_t = ::libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header {
    pub magic: multiboot_uint32_t,
    pub architecture: multiboot_uint32_t,
    pub header_length: multiboot_uint32_t,
    pub checksum: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_header))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).architecture as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(architecture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).header_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(header_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header>())).checksum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header),
            "::",
            stringify!(checksum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_header_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_header_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header_tag>())).flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_header_tag>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_header_tag_information_request {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub requests: __IncompleteArrayField<multiboot_uint32_t>,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_information_request() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_information_request>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_header_tag_information_request)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_information_request>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_information_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_information_request>())).requests
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_information_request),
            "::",
            stringify!(requests)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_address {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub header_addr: multiboot_uint32_t,
    pub load_addr: multiboot_uint32_t,
    pub load_end_addr: multiboot_uint32_t,
    pub bss_end_addr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_address() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_address>(),
        24usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_address))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_address>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_header_tag_address))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).flags as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).header_addr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(header_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).load_addr as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(load_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).load_end_addr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(load_end_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_address>())).bss_end_addr as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_address),
            "::",
            stringify!(bss_end_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_entry_address {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub entry_addr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_entry_address() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_entry_address>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_entry_address))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_entry_address>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_entry_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_entry_address>())).entry_addr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_entry_address),
            "::",
            stringify!(entry_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_console_flags {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub console_flags: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_console_flags() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_console_flags>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_console_flags))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_console_flags>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_console_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_console_flags>())).console_flags
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_console_flags),
            "::",
            stringify!(console_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_framebuffer {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub width: multiboot_uint32_t,
    pub height: multiboot_uint32_t,
    pub depth: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_framebuffer() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_framebuffer>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_framebuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_framebuffer>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).flags as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_framebuffer>())).depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_framebuffer),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_header_tag_module_align {
    pub type_: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub size: multiboot_uint32_t,
    pub width: multiboot_uint32_t,
    pub height: multiboot_uint32_t,
    pub depth: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_header_tag_module_align() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_header_tag_module_align>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_header_tag_module_align))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_header_tag_module_align>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_header_tag_module_align)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).flags as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).width as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_header_tag_module_align>())).depth as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_header_tag_module_align),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_color {
    pub red: multiboot_uint8_t,
    pub green: multiboot_uint8_t,
    pub blue: multiboot_uint8_t,
}
#[test]
fn bindgen_test_layout_multiboot_color() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_color>(),
        3usize,
        concat!("Size of: ", stringify!(multiboot_color))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_color>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_color))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_color>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_color),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_color>())).green as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_color),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_color>())).blue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_color),
            "::",
            stringify!(blue)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_mmap_entry {
    pub addr: multiboot_uint64_t,
    pub len: multiboot_uint64_t,
    pub type_: multiboot_uint32_t,
    pub zero: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_mmap_entry() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_mmap_entry>(),
        24usize,
        concat!("Size of: ", stringify!(multiboot_mmap_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_mmap_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_mmap_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mmap_entry>())).zero as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mmap_entry),
            "::",
            stringify!(zero)
        )
    );
}
pub type multiboot_memory_map_t = multiboot_mmap_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_string {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub string: __IncompleteArrayField<::libc::c_char>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_string() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_string>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_string))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_string>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_string))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_string>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_string),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_string>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_string),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_string>())).string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_string),
            "::",
            stringify!(string)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_module {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub mod_start: multiboot_uint32_t,
    pub mod_end: multiboot_uint32_t,
    pub cmdline: __IncompleteArrayField<::libc::c_char>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_module() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_module>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_module))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_module>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_module))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).mod_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(mod_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).mod_end as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(mod_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_module>())).cmdline as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_module),
            "::",
            stringify!(cmdline)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_basic_meminfo {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub mem_lower: multiboot_uint32_t,
    pub mem_upper: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_basic_meminfo() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_basic_meminfo>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_basic_meminfo))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_basic_meminfo>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_basic_meminfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).mem_lower as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(mem_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_basic_meminfo>())).mem_upper as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_basic_meminfo),
            "::",
            stringify!(mem_upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_bootdev {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub biosdev: multiboot_uint32_t,
    pub slice: multiboot_uint32_t,
    pub part: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_bootdev() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_bootdev>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_tag_bootdev))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_bootdev>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_bootdev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).biosdev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(biosdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).slice as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_bootdev>())).part as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_bootdev),
            "::",
            stringify!(part)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_mmap {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub entry_size: multiboot_uint32_t,
    pub entry_version: multiboot_uint32_t,
    pub entries: __IncompleteArrayField<multiboot_mmap_entry>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_mmap() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_mmap>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_mmap))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_mmap>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_mmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).entry_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(entry_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_mmap>())).entry_version as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(entry_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_mmap>())).entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_mmap),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiboot_vbe_info_block {
    pub external_specification: [multiboot_uint8_t; 512usize],
}
#[test]
fn bindgen_test_layout_multiboot_vbe_info_block() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_vbe_info_block>(),
        512usize,
        concat!("Size of: ", stringify!(multiboot_vbe_info_block))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_vbe_info_block>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_vbe_info_block))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_vbe_info_block>())).external_specification as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_vbe_info_block),
            "::",
            stringify!(external_specification)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiboot_vbe_mode_info_block {
    pub external_specification: [multiboot_uint8_t; 256usize],
}
#[test]
fn bindgen_test_layout_multiboot_vbe_mode_info_block() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_vbe_mode_info_block>(),
        256usize,
        concat!("Size of: ", stringify!(multiboot_vbe_mode_info_block))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_vbe_mode_info_block>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_vbe_mode_info_block))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_vbe_mode_info_block>())).external_specification
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_vbe_mode_info_block),
            "::",
            stringify!(external_specification)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiboot_tag_vbe {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub vbe_mode: multiboot_uint16_t,
    pub vbe_interface_seg: multiboot_uint16_t,
    pub vbe_interface_off: multiboot_uint16_t,
    pub vbe_interface_len: multiboot_uint16_t,
    pub vbe_control_info: multiboot_vbe_info_block,
    pub vbe_mode_info: multiboot_vbe_mode_info_block,
}
#[test]
fn bindgen_test_layout_multiboot_tag_vbe() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_vbe>(),
        784usize,
        concat!("Size of: ", stringify!(multiboot_tag_vbe))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_vbe>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_vbe))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_vbe>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_vbe>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_interface_seg as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_interface_seg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_interface_off as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_interface_off)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_interface_len as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_interface_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_control_info as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_control_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_vbe>())).vbe_mode_info as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_vbe),
            "::",
            stringify!(vbe_mode_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_framebuffer_common {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub framebuffer_addr: multiboot_uint64_t,
    pub framebuffer_pitch: multiboot_uint32_t,
    pub framebuffer_width: multiboot_uint32_t,
    pub framebuffer_height: multiboot_uint32_t,
    pub framebuffer_bpp: multiboot_uint8_t,
    pub framebuffer_type: multiboot_uint8_t,
    pub reserved: multiboot_uint16_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer_common() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer_common>(),
        32usize,
        concat!("Size of: ", stringify!(multiboot_tag_framebuffer_common))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer_common>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer_common)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_addr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_pitch
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_width
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_height
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_bpp
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_bpp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).framebuffer_type
                as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(framebuffer_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer_common>())).reserved as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer_common),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
pub struct multiboot_tag_framebuffer {
    pub common: multiboot_tag_framebuffer_common,
    pub __bindgen_anon_1: multiboot_tag_framebuffer__bindgen_ty_1,
}
#[repr(C)]
pub struct multiboot_tag_framebuffer__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2:
        __BindgenUnionField<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u16; 3usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1 {
    pub framebuffer_palette_num_colors: multiboot_uint16_t,
    pub framebuffer_palette: __IncompleteArrayField<multiboot_color>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>()))
                .framebuffer_palette_num_colors as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(framebuffer_palette_num_colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1>()))
                .framebuffer_palette as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(framebuffer_palette)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2 {
    pub framebuffer_red_field_position: multiboot_uint8_t,
    pub framebuffer_red_mask_size: multiboot_uint8_t,
    pub framebuffer_green_field_position: multiboot_uint8_t,
    pub framebuffer_green_mask_size: multiboot_uint8_t,
    pub framebuffer_blue_field_position: multiboot_uint8_t,
    pub framebuffer_blue_mask_size: multiboot_uint8_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_red_field_position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_red_field_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_red_mask_size as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_red_mask_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_green_field_position as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_green_field_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_green_mask_size as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_green_mask_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_blue_field_position as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_blue_field_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2>()))
                .framebuffer_blue_mask_size as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(framebuffer_blue_mask_size)
        )
    );
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer__bindgen_ty_1>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(multiboot_tag_framebuffer__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_multiboot_tag_framebuffer() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_framebuffer>(),
        40usize,
        concat!("Size of: ", stringify!(multiboot_tag_framebuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_framebuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_tag_framebuffer))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_framebuffer>())).common as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_framebuffer),
            "::",
            stringify!(common)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_elf_sections {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub num: multiboot_uint32_t,
    pub entsize: multiboot_uint32_t,
    pub shndx: multiboot_uint32_t,
    pub sections: __IncompleteArrayField<::libc::c_char>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_elf_sections() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_elf_sections>(),
        20usize,
        concat!("Size of: ", stringify!(multiboot_tag_elf_sections))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_elf_sections>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_elf_sections))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).entsize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(entsize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).shndx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(shndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_elf_sections>())).sections as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_elf_sections),
            "::",
            stringify!(sections)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_apm {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub version: multiboot_uint16_t,
    pub cseg: multiboot_uint16_t,
    pub offset: multiboot_uint32_t,
    pub cseg_16: multiboot_uint16_t,
    pub dseg: multiboot_uint16_t,
    pub flags: multiboot_uint16_t,
    pub cseg_len: multiboot_uint16_t,
    pub cseg_16_len: multiboot_uint16_t,
    pub dseg_len: multiboot_uint16_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_apm() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_apm>(),
        28usize,
        concat!("Size of: ", stringify!(multiboot_tag_apm))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_apm>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_apm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg_16 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).dseg as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(dseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg_len as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).cseg_16_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(cseg_16_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_apm>())).dseg_len as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_apm),
            "::",
            stringify!(dseg_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi32 {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub pointer: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi32() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi32>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi32))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi32>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi32>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi32),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi32>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi32),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi32>())).pointer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi32),
            "::",
            stringify!(pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi64 {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub pointer: multiboot_uint64_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi64() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi64>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi64))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi64>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi64>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi64),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi64>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi64),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi64>())).pointer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi64),
            "::",
            stringify!(pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_smbios {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub major: multiboot_uint8_t,
    pub minor: multiboot_uint8_t,
    pub reserved: [multiboot_uint8_t; 6usize],
    pub tables: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_smbios() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_smbios>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_smbios))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_smbios>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_smbios))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).major as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).minor as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).reserved as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_smbios>())).tables as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_smbios),
            "::",
            stringify!(tables)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_old_acpi {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub rsdp: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_old_acpi() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_old_acpi>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_old_acpi))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_old_acpi>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_old_acpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_old_acpi>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_old_acpi),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_old_acpi>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_old_acpi),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_old_acpi>())).rsdp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_old_acpi),
            "::",
            stringify!(rsdp)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_new_acpi {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub rsdp: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_new_acpi() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_new_acpi>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_new_acpi))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_new_acpi>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_new_acpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_new_acpi>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_new_acpi),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_new_acpi>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_new_acpi),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_new_acpi>())).rsdp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_new_acpi),
            "::",
            stringify!(rsdp)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_network {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub dhcpack: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_network() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_network>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_network))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_network>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_network))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_network>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_network),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_network>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_network),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_network>())).dhcpack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_network),
            "::",
            stringify!(dhcpack)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct multiboot_tag_efi_mem_map {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub desc_size: multiboot_uint32_t,
    pub desc_version: multiboot_uint32_t,
    pub efi_mem_map: __IncompleteArrayField<multiboot_uint8_t>,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_mem_map() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_mem_map>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_mem_map))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_mem_map>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_mem_map))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).desc_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(desc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).desc_version as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(desc_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_mem_map>())).efi_mem_map as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_mem_map),
            "::",
            stringify!(efi_mem_map)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi_boot_serv {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_boot_serv() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_boot_serv>(),
        8usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_boot_serv))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_boot_serv>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_boot_serv))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_boot_serv>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_boot_serv),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_boot_serv>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_boot_serv),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi_32b_image {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub ptr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_32b_image() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_32b_image>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_32b_image))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_32b_image>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_32b_image))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_32b_image>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_32b_image),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_32b_image>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_32b_image),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_32b_image>())).ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_32b_image),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_efi_64b_image {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub ptr: multiboot_uint64_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_efi_64b_image() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_efi_64b_image>(),
        16usize,
        concat!("Size of: ", stringify!(multiboot_tag_efi_64b_image))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_efi_64b_image>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_tag_efi_64b_image))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_64b_image>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_64b_image),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_64b_image>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_64b_image),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_efi_64b_image>())).ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_efi_64b_image),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_image_load_base {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub addr: multiboot_uint32_t,
}
#[test]
fn bindgen_test_layout_multiboot_tag_image_load_base() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_image_load_base>(),
        12usize,
        concat!("Size of: ", stringify!(multiboot_tag_image_load_base))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_image_load_base>(),
        4usize,
        concat!("Alignment of ", stringify!(multiboot_tag_image_load_base))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_image_load_base>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_image_load_base),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_image_load_base>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_image_load_base),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_image_load_base>())).addr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_image_load_base),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_tag_hrt {
    pub type_: multiboot_uint32_t,
    pub size: multiboot_uint32_t,
    pub total_num_apics: multiboot_uint32_t,
    pub first_hrt_apic_id: multiboot_uint32_t,
    pub have_hrt_ioapic: multiboot_uint32_t,
    pub first_hrt_ioapic_entry: multiboot_uint32_t,
    pub cpu_freq_khz: multiboot_uint64_t,
    pub hrt_flags: multiboot_uint64_t,
    pub max_mem_mapped: multiboot_uint64_t,
    pub first_hrt_gpa: multiboot_uint64_t,
    pub boot_state_gpa: multiboot_uint64_t,
    pub gva_offset: multiboot_uint64_t,
    pub comm_page_gpa: multiboot_uint64_t,
    pub hrt_int_vec: multiboot_uint8_t,
    pub reserved: [multiboot_uint8_t; 7usize],
}
#[test]
fn bindgen_test_layout_multiboot_tag_hrt() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_tag_hrt>(),
        88usize,
        concat!("Size of: ", stringify!(multiboot_tag_hrt))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_tag_hrt>(),
        1usize,
        concat!("Alignment of ", stringify!(multiboot_tag_hrt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).total_num_apics as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(total_num_apics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).first_hrt_apic_id as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(first_hrt_apic_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).have_hrt_ioapic as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(have_hrt_ioapic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).first_hrt_ioapic_entry as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(first_hrt_ioapic_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).cpu_freq_khz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(cpu_freq_khz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).hrt_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(hrt_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).max_mem_mapped as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(max_mem_mapped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).first_hrt_gpa as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(first_hrt_gpa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).boot_state_gpa as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(boot_state_gpa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).gva_offset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(gva_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<multiboot_tag_hrt>())).comm_page_gpa as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(comm_page_gpa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).hrt_int_vec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(hrt_int_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_tag_hrt>())).reserved as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_tag_hrt),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn multiboot_get_size(mbd: ulong_t) -> uint_t;
}
extern "C" {
    pub fn multiboot_get_phys_mem(mbd: ulong_t) -> addr_t;
}
extern "C" {
    pub fn multiboot_get_modules_end(mbd: ulong_t) -> addr_t;
}
extern "C" {
    pub fn multiboot_get_sys_ram(mbd: ulong_t) -> ulong_t;
}
extern "C" {
    pub fn multiboot_parse(mbd: ulong_t, magic: ulong_t) -> *mut multiboot_info;
}
extern "C" {
    pub fn mb_is_hrt_environ(mbd: ulong_t) -> ::libc::c_int;
}
extern "C" {
    pub fn mb_get_first_hrt_addr(mbd: ulong_t) -> *mut ::libc::c_void;
}
pub const mod_type_t_MOD_SYMTAB: mod_type_t = 0;
pub const mod_type_t_MOD_PROGRAM: mod_type_t = 1;
pub type mod_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_mod {
    pub start: addr_t,
    pub end: addr_t,
    pub type_: mod_type_t,
    pub cmdline: *mut ::libc::c_char,
    pub elm: list_head,
}
#[test]
fn bindgen_test_layout_multiboot_mod() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_mod>(),
        48usize,
        concat!("Size of: ", stringify!(multiboot_mod))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_mod>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_mod))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mod>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mod),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mod>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mod),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mod>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mod),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mod>())).cmdline as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mod),
            "::",
            stringify!(cmdline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_mod>())).elm as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_mod),
            "::",
            stringify!(elm)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot_info {
    pub boot_loader: *mut ::libc::c_char,
    pub boot_cmd_line: *mut ::libc::c_char,
    pub sec_hdr_start: *mut ::libc::c_void,
    pub hrt_info: *mut multiboot_tag_hrt,
    pub mod_count: ::libc::c_int,
    pub mod_list: list_head,
}
#[test]
fn bindgen_test_layout_multiboot_info() {
    assert_eq!(
        ::core::mem::size_of::<multiboot_info>(),
        56usize,
        concat!("Size of: ", stringify!(multiboot_info))
    );
    assert_eq!(
        ::core::mem::align_of::<multiboot_info>(),
        8usize,
        concat!("Alignment of ", stringify!(multiboot_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_info>())).boot_loader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_info),
            "::",
            stringify!(boot_loader)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_info>())).boot_cmd_line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_info),
            "::",
            stringify!(boot_cmd_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_info>())).sec_hdr_start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_info),
            "::",
            stringify!(sec_hdr_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_info>())).hrt_info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_info),
            "::",
            stringify!(hrt_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_info>())).mod_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_info),
            "::",
            stringify!(mod_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<multiboot_info>())).mod_list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(multiboot_info),
            "::",
            stringify!(mod_list)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_sched_percpu_state {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct numa_domain {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_rand_info {
    pub _address: u8,
}
